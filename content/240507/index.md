---
emoji: 🧑🏻‍🏫
title: '멘토링 1회차 복습'
date: '2024-05-07'
categories: 멘토링 자바스크립트
---

독학으로 공부를 계속하다 회사에 다닌 지 1년이 넘은 현시점에서, 스스로를 객관적으로 돌이켜보기 위해서 멘토링을 신청하게 되었다!

멘토링을 하면서 느낀 경험을 1주일 단위 회고 형식으로 진행해보려 한다.

첫 번째 주차의 회고를 진행해보겠다 **(24.04.30 ~ 24.05.06)**

<br>

## 일단.. 다시 공부가 필요한 것들 복습하자

돌이켜 생각해보면 잘 몰랐던 것들은 계속 모르거나 헷갈리고 있다. ~~(나 자신을 똥 멍청이라 생각한다ㅠ.. 그래도 천재가 되기 위해서 차근차근 복습해보자)~~

![1.gif](1.gif)

<br>

### 깊은 복사와 얕은 복사의 차이

**얕은 복사(Shallow Copy)는** 원본 객체의 최상위 수준의 속성들을 복사하고, 내부의 객체는 참조를 공유한다. 즉, 내부 객체에 대한 변경은 복사된 객체와 원본 객체 양쪽에 모두 영향을 주고, 최상위 수준의 속성이 필요한 경우에 사용한다.

**깊은 복사(Deep Copy)는** 원본 객체의 모든 속성들을 재귀적으로 복사해 원본 객체와 완전한 독립이다. 내부 객체까지 새로운 객체로 복사되어, 다른 객체에 영향을 주지 않고 복잡한 구조를 가진 객체를 다루기위해 사용한다.

<br>

### 왜 모던 웹에서 불변성을 지켜야할까?

내가 뭐라고 했는지 정확히 기억나지 않지만, 불변성을 지켜야 의도하지 않은 데이터 변경을 막을 수 있다고 했던 것 같다. 비슷하긴 하지만 찾아보니 더 다양한 내용이 있다는 걸 알게되었다~!

1. 불변성을 유지하면 **상태 변경을 추적하고 이전 상태로 되돌리는 것이 수월**해 관리하는 데 도움이 된다.
2. 불변성을 유지하면 **코드의 동작이 예측 가능해 디버깅에 수월**하다.
3. 불변성 덕분에 변경이 없는 객체 또는 배열을 공유할 수 있고, 메모리를 절약해 변경 감지를 위한 **추가적인 비용을 줄일 수 있다.**
4. 불변성은 다중 스레드 환경에서 데이터 공유를 안전하게 만들기 때문에, 여러 스레드가 동시에 데이터를 변경하려고 할 때와 같이 **예기치 않은 결과를 방지하고 동기화 문제를 피할 수 있다.**
5. **순수 함수**(동일한 입력에 대해 항상 동일한 출력을 반환하는 함수이다. 외부 상태에 의존하지 않고, 상태를 변경하지 않아 영향을 미치지 않아서 부작용이 없다)와 함께 사용 가능하다.

<br>

### 실행 컨텍스트에 대해서

실행 컨텍스트 공부 엄청했다ㅠㅠ.. 그런데 말을 못하겠어.. 일단 영어단어도 너무너무 어렵고.. 하지만 더 공부해서 그림까지 완벽하게 그려보도록 하겠다.

해당하는 자료들은 책에도 너무너무 많고. 동영상도 너무 많다. 내가 여기에 기록하지 않고 좋은 자료를 첨부하도록 하겠다! => 솔직히 이거 2개만 다 이해하면 당신은 JS엔진

- [설명 킹왕짱 시니어코딩님](https://www.youtube.com/watch?v=pfQfEwnJHRs&t=1597s)
- [이게 공짜라니.. 제로초님의 인간 JS 엔진 되기](https://www.youtube.com/playlist?list=PLcqDmjxt30Rt9wmSlw1u6sBYr-aZmpNB3)

<br>

> **콜 스택과 실행 컨텍스트는 어떤 연관이 있을까??**
>
> 실행 컨텍스트와 콜 스택은 서로 상호 작용하여 코드의 실행 흐름을 관리한다. 함수가 호출되면 해당 함수의 실행 컨텍스트가 호출 스택에 푸시(Push)되고, 해당 함수의 실행이 완료되면 호출 스택에서 팝(Pop)된다. 이러한 과정을 통해 자바스크립트 엔진은 코드의 실행 순서를 유지하고 실행 중인 함수의 상태를 추적한다.
>
> 실행 컨텍스트는 실행 환경을 추상화하고 관리하며, 호출 스택은 실행 중인 실행 컨텍스트의 순서를 관리하여 코드의 실행 흐름을 유지

<br>

> **자바스크립트 한 함수의 생명주기 (with 실행 컨텍스트)**
>
> 생성(Create) => 호출(Call) => 실행(Execute) => 완료(Complete)
>
> 함수가 정의되어, 메모리가 로드되고 함수 객체가 생성된다. 함수 객체는 코드와 스코프 체인을 포함한 실행 컨텍스트를 생성 (생성)
>
> 함수가 호출되면 새로운 실행 컨텍스트가 생성되는데, 이 실행 컨텍스트는 함수의 변수, 매개변수, 스코프 체인 등을 포함하며, 호출 스택에 푸시된다. (호출)
>
> 실행 컨텍스트가 활성화되면 함수의 코드가 실행되고, 그 동안 변수의 값이 변경되고, 새로운 함수가 호출되거나 반환될 수 있다. (실행)
>
> 함수의 실행이 완료되면 실행 컨텍스트가 호출 스택에서 팝되고, 메모리에서 제거되어 함수의 결과가 반환됨 (완료)

<br>

> **이벤트 루프(Event Loop)**
>
> 콜 스택과 백그라운드(Task Queue 또는 Microtask Queue)를 모니터링하고, 이벤트 루프가 비어있을 때 백그라운드에서 실행된 작업(Task Queue)을 콜 스택으로 이동시켜주는데, Task Queue에 있는 작업들은 비동기적인 작업의 결과뿐만 아니라, 이벤트 핸들러나 타이머 콜백 등도 포함된다.
>
> 또한 마이크로테스크 큐(Microtask Queue)를 모니터링하여 콜 스택의 작업이 완료된 후에 마이크로테스크를 우선적으로 처리합니다.

<br>

### 마이크로테스크와 매크로테스크 차이점은??

솔직히!! 콜스텍에 대해서 공부하면서 보았는데..ㅠㅠ 말로 대답하려니 엄~~청 햇갈려서 대답 못했다ㅠㅠ.. 다시 복습하자!!!

![2.jpeg](2.jpeg)

우선 마이크로테스크(Microtask)와 매크로테스크(Macrotask)는 자바스크립트 비동기 처리에 사용되는 용어다!

**실행 시점의 차이**

- 매크로테스크: 매크로테스크는 브라우저의 이벤트 루프에서 처리되는 비동기 작업으로, 주로 큐(Queue)에 들어간 이벤트 핸들러(DOM 이벤트 핸들러)나 타이머 콜백(setTimeout, setInterval) 등이 해당된다.
- 마이크로테스크: 매크로테스크보다 더 높은 우선순위를 가지며, Promise의 then, catch, finally 메서드와 같은 비동기 작업이 해당된다. 마이크로테스크는 현재 매크로테스크 큐의 처리가 끝나고 다음 태스크를 실행하기 전에 처리된다.

<br>

**실행 순서의 차이**

- 매크로테스크: **이벤트 루프의 한 사이클이 완료된 후에 실행된다.** 현재 실행 중인 코드 블록이 완료되지 않아도 처리된다.
- 마이크로테스크: 매크로테스크보다 더 높은 우선순위를 가지므로, **현재 실행 중인 코드 블록이 완료된 후에 처리된다.** 따라서 마이크로테스크는 매크로테스크보다 먼저 실행됩니다.

<br>

### 스코프체인과 스코프

**스코프(Scope)는** 변수와 함수에 대한 접근성 및 가시성을 결정하는 개념으로 자바스크립트에서는 스코프를 정적으로 지정한다. 코드가 실행되기 전에 어디서 변수나 함수에 접근할 수 있는지 결정된다. 스코프는 코드의 블록(함수, if문, for문 등) 내에서 변수와 함수에 접근할 수 있는 범위를 정의한다.

**스코프체인(Scope Chain)은** 변수와 함수에 대한 접근을 결정하기 위한 메커니즘으로, 변수나 함수를 참조할 때 해당 식별자를 검색하는 순서를 결정한다. 일반적으로 스코프체인은 현재 실행 중인 컨텍스트의 변수 객체와 그 부모 컨텍스트의 변수 객체를 연결한 체인이다.

> 간단하게 생각하면 **스코프는 해당 코드의 범위를 의미** 하고 **스코프체인은 자기 자신의 스코프를 제외한 자신과 가장 가까운 변수 객체의 모든 스코프들이라고 생각한다!**

<br>

### 함수 스코프와 블록 스코프

내가 뭐라고했더라.. ㅋㅋㅋ 함수선언 내부 범위가 함수 스코프고 블록 스코프는 함수를 제외한 변수, 객체의 내부 범위가 블록 스코프라고 했다. 뭐 얼추만 비슷하기에 정확히 알아보자!

**함수 스코프는** 변수가 선언된 함수 내에서만 유효한 스코프로 함수 내에서 선언된 변수는 함수 내에서만 접근할 수 있다. 함수 스코프 내부에서 선언된 변수는 내부에서만 유효하기 때문에 함수 외부에서는 접근할 수 없다

**블록 스코프는** 변수가 선언된 블록 내에서만 유효한 스코프로, 블록은 중괄호 {}로 묶인 코드 영역을 의미한다. 블록 스코프는 주로 if, for, while과 같은 제어문의 블록 내에서 변수를 선언할 때 사용되고 블록 스코프 내부의 변수는 블록 내에서만 유효하면 블록 외부에서는 접근할 수 없다

> 간단하게 요약하면 **함수 스코프는 변수가 선언된 함수 내에서만 유효**하고, **블록 스코프는 변수가 선언된 블록 내에서만 유효**하다.

<br>

### 생성자 함수의 this, 메서드의 this

**메서드(Method)에서의 this는** 해당 메서드가 속한 객체를 가리키고 메서드가 호출된 객체에 바인딩된다. 이를 통해 메서드는 자신이 속한 객체의 속성에 접근할 수 있다.

```javascript
const obj = {
  name: 'Jihoon',
  greet: function () {
    console.log('Hello, ' + this.name);
  },
};
obj.greet(); // 출력: "Hello, Jihoon"
```

**생성자 함수(Constructor Function)에서의 this는** 새로 생성되는 객체를 가리킨다. 생성자 함수는 new 키워드를 사용하여 호출될 때마다 새로운 객체가 생성되고, 이 객체가 this에 바인딩된다.

```javascript
function Person(name) {
  this.name = name;
  this.greet = function () {
    console.log('Hello, ' + this.name);
  };
}
const Jihoon = new Person('Jihoon');
Jihoon.greet(); // 출력: "Hello, Jihoon"
```

<br>

### 일급 함수(First-class Function)

사이드 이팩트가 없고 부작용이 없는 순수함수는 들어보았지만, 1급 함수에 대한 개념은 잡혀있지 않았다. 과연 뭘까?

일급 함수는 프로그래밍 언어에서 함수를 일반 값과 동등하게 취급하는 것을 의미하고 아래 조건을 만족한다.

**1. 변수에 할당하여 함수를 변수로 사용할 수 있다.**

```javascript
const myFunc = function () {
  console.log('Hello, world!');
};
myFunc(); // 출력: "Hello, world!"
```

**2. 함수를 다른 함수의 매개변수로 전달할 수 있다.**

```javascript
function greet(func) {
  func();
}
greet(function () {
  console.log('Hello, world!');
}); // 출력: "Hello, world!"
```

**3. 함수가 다른 함수의 반환값으로 사용될 수 있다.**

```javascript
function createFunc() {
  return function () {
    console.log('Hello, world!');
  };
}
const myFunc = createFunc();
myFunc(); // 출력: "Hello, world!"
```

<br>

## 5월 첫째 주 회고

좋은 점, 반성할 점, 진행하고 있는 부분 등에 대해서 다양하게 기록해보고 피드백해 보자

### 이번 주 좋은 것과 나쁜 것

- 휴일이 많아서 회사에서 못한 부분을 개인 시간에 진행할 수 있었다.
- 멘토링을 본격적으로 시작하기전 사람들과 사람들을 많이 만나고, 이야기를 나누는 시간을 가져서 체력적으로 좀 피곤했다.

### 이번주 진행했던 학습/개발 내용은??

- 사내의 Devextreme 으로 구성된 것을 Mui + react-hook-form + zod 를 이용하는 것으로 바꾸고 있으며, Custom UI를 만들고 있다.
- 사내 동료들에게 실행컨텍스트, 콜스택, 클로저의 개념에 대해서 발표하는 시간을 가졌다.
- 코어 자바스크립트 1~3장 읽으며 멘토링을 준비하였다.

### 가장 고민했던 부분은 무엇이었나요?

- 제네릭을 효율적으로 쓰는 방법? 그리고 어떠한 상황에 써야 되는지 고민 진행 중입니다.
- 사내 프로젝트에서 상태관리가 너무 복잡하게 되어있어서, 이것을 top-down, bottom-up 방식을 동시에 써야 할지 고민 중입니다.
- 동아리에서 youdontknowjs 의 클로저 부분을 읽고 자료를 정리해야 되는데, 어떤 내용을 중점으로 다룰지 고민 중입니다.

### 아쉬운 부분을 개선하는 데 필요한 것은 무엇인가요?

- 어떤 것을 집중해서 맡은 것을 끝내려는 집중력이 필요합니다.
- 여러 가지를 동시에 해내는 것은 불가능하다고 생각하니, 여유를 가지는 것도 중요하다고 생각합니다
- 다양한 회사에서 원하는 JD 파악을 해야 합니다.

### 다음 주는 어떻게 보낼 예정인가요?

- 멘토링이 끝난 당일과 다음날은 복습 위주로 진행할 것입니다
- 동아리에서 맡은 역할이 있어서 해결할 예정입니다. (클로저, react hook에 대한 자료정리)
- 동아리에서 진행하는 행사 계획에 대한 회의를 진행할 것 입니다
- 앞의 복습내용을 바탕으로 코어 자바스크립트 4~6장을 읽을 예정입니다
- 5/9 우당탕탕 책방이라는 모임에서 CSS 라이브러리에 관한 이야기를 진행해서 준비할 예정입니다.

<br>

![3.jpeg](3.jpeg)

```toc

```
