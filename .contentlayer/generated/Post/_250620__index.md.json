{
  "title": "as const 한 줄로 만드는 타입 안정성",
  "date": "2025-06-20T00:00:00.000Z",
  "categories": "프론트엔드 TypeScript",
  "body": {
    "raw": "\n프론트엔드 실무에서 `as const`를 단순히 타입 추론을 돕는 보조 수단이 아니라, **불변성 선언과 동시에 타입의 리터럴화를 통해 안정성과 자동완성을 극대화**할 수 있는 툴로 유용하게 사용하고 있다.\n\n이번 글에서는 실무에서 `as const`의 활용 사례를 중심으로 활용과 원리까지 깊이 있게 다뤄보려 한다.\n\n---\n\n## as const\n\n`as const`는 TypeScript에서 **값을 리터럴 타입으로 고정(literal narrowing)** 하기 위한 단언문이다.\n\n```ts\nconst button = \"primary\";         // 타입: string\nconst button = \"primary\" as const; // 타입: \"primary\"\n```\n\n배열이나 객체에 쓰면 해당 구조를 읽기 전용(readonly)으로 만들면서 각 요소의 타입을 리터럴로 고정한다.\n\n```ts\nconst status = [\"idle\", \"loading\"] as const;\n// 타입: readonly [\"idle\", \"loading\"]\n```\n\n이처럼 **값을 변경 불가능한 상수로 명시**하고, 타입도 좁게 고정되도록 만드는 것이 핵심이다.\n\n---\n\n### TanStack Query – query key 안정성 확보\n\n```ts\nconst queryKey = [\"user\", userId] as const;\nuseQuery({ queryKey, queryFn });\n```\n\n여기서 `as const`를 쓰지 않으면 queryKey는 `(string | number)[]`로 추론되어 타입 안정성이 떨어진다.\n\n반면 `as const`를 쓰면 queryKey가 정확히 `readonly [\"user\", string]`이 되어, **query key가 고정된 식별자로 취급**되고, 캐싱/비교/인밸리데이션에서도 더 안정적으로 작동한다.\n\n---\n\n### React Router – 라우팅과 같은 객체 구조의 키값 고정\n\n```ts\nconst router = createBrowserRouter([\n  { path: \"/home\", element: <HomePage /> },\n  { path: \"/about\", element: <AboutPage /> }\n] as const);\n```\n\nReact Router는 내부적으로 라우트 배열을 순회하면서 타입을 추론하려고 하기 때문에, `as const`로 선언해주면 각 path의 리터럴 값(`\"/home\"`, `\"/about\"`)을 정확히 추론할 수 있다.\n\n이를 통해 **라우트 기반 자동완성, 타입 기반 네비게이션 제어**가 가능해진다.\n\n---\n\n## `as const`를 쓰지 않아야 할 때\n\n무조건 좁은 타입이 좋은 건 아니다. 다음과 같은 경우는 오히려 `as const`를 쓰지 않는 것이 낫다.\n\n```ts\nlet status = \"idle\" as const;\n```\n\n이렇게 하면 `status`는 절대 다른 문자열을 가질 수 없기 때문에, 동적으로 상태를 변경해야 하는 경우엔 적절치 않다.\n\n--- \n\n```ts\nfunction update(type: \"create\" | \"delete\") {}\nupdate(\"create\" as const); // 불필요\n```\n\n함수 시그니처가 리터럴 타입을 받는 경우, 이미 문자열 리터럴을 넣으면 타입이 자동으로 좁혀진다. 명시적 `as const`는 오히려 코드만 장황해질 수 있다.\n\n---\n\n## 내부 동작 원리 – const assertion의 타입화\n\nTypeScript에서 `as const`는 해당 값은 **readonly**로 간주되고, 가능한 한 좁은 타입으로 **리터럴 추론**을 한다.\n\n```ts\nconst obj = { a: 1, b: \"x\" } as const;\n// 타입: { readonly a: 1; readonly b: \"x\"; }\n```\n\n이는 일종의 **const assertion**으로, 값 자체는 JS에서 변하지 않지만 타입도 함께 고정시키는 것이 특징이다.\n\n배열, 객체, 튜플 등에 모두 적용 가능하며, **유형 안정성(type safety)을 명시적으로 선언하는 수단**이다.\n\n---\n\n### 기술적으로 조금 더 깊게 들어가면\n\nTypeScript는 `as const`를 만나면 해당 값 전체를 readonly로 처리하며, 내부 속성 하나하나를 리터럴 타입으로 고정한다.\n\n이는 내부적으로 `const T: { readonly a: 1, readonly b: \"x\" }` 같은 형태로 변환된다.\n\n제네릭 함수에서 `as const`된 인자를 넘기면, 추론된 타입이 정확한 리터럴 형태로 유지되기 때문에 타입 제한, 자동완성, 추론 정확도가 크게 향상된다.\n\n특히 readonly 튜플로 바뀐다는 점에서, 배열 기반 추론(예: query key 등)에 매우 큰 이점을 준다.\n\n```ts\nconst key = [\"user\", 1] as const;\ntype Key = typeof key; // readonly [\"user\", 1]\n```\n\n만약 `as const` 없이 선언했다면 `Key`는 `(string | number)[]`이 되었을 것이고, 타입 정합성은 깨졌을 것이다.\n\n---\n\n## `enum`과 비슷하지만 다르다.\n\n`as const`와 `enum`은 모두 **값 집합을 고정시키는** 용도로 사용되지만, 아래와 같은 차이가 있다.\n\n---\n\n| 항목           | `as const`  | `enum`        |\n| ------------ | ----------- | ------------- |\n| 런타임 존재 여부    | 값 그 자체      | 객체 생성됨        |\n| 타입 유추 방식     | 리터럴 타입으로 추론 | 명시적 타입 선언 필요  |\n| Tree-shaking | 가능          | 어려움           |\n| JS 출력 코드     | 없음          | 존재 (실제 객체 생성) |\n\n\n```ts\ntype Mode = (typeof MODES)[number];\n\nconst MODES = [\"light\", \"dark\"] as const;\n\nenum ModeEnum {\n  Light = \"light\",\n  Dark = \"dark\"\n}\n```\n\n대부분의 경우 **불필요한 런타임 비용 없이 타입만 고정하고 싶을 때는 `as const`가 더 효율적**이다.\n\n\n\n```toc\n```",
    "html": "<p>프론트엔드 실무에서 <code>as const</code>를 단순히 타입 추론을 돕는 보조 수단이 아니라, <strong>불변성 선언과 동시에 타입의 리터럴화를 통해 안정성과 자동완성을 극대화</strong>할 수 있는 툴로 유용하게 사용하고 있다.</p>\n<p>이번 글에서는 실무에서 <code>as const</code>의 활용 사례를 중심으로 활용과 원리까지 깊이 있게 다뤄보려 한다.</p>\n<hr>\n<h2 id=\"as-const\"><a class=\"anchor\" href=\"#as-const\">as const</a></h2>\n<p><code>as const</code>는 TypeScript에서 <strong>값을 리터럴 타입으로 고정(literal narrowing)</strong> 하기 위한 단언문이다.</p>\n<figure data-rehype-pretty-code-figure=\"\"><pre tabindex=\"0\" data-language=\"ts\" data-theme=\"github-dark github-light\"><code data-language=\"ts\" data-theme=\"github-dark github-light\" style=\"display: grid;\"><span data-line=\"\"><span style=\"--shiki-dark:#F97583;--shiki-light:#D73A49\">const</span><span style=\"--shiki-dark:#79B8FF;--shiki-light:#005CC5\"> button</span><span style=\"--shiki-dark:#F97583;--shiki-light:#D73A49\"> =</span><span style=\"--shiki-dark:#9ECBFF;--shiki-light:#032F62\"> \"primary\"</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">;         </span><span style=\"--shiki-dark:#6A737D;--shiki-light:#6A737D\">// 타입: string</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#F97583;--shiki-light:#D73A49\">const</span><span style=\"--shiki-dark:#79B8FF;--shiki-light:#005CC5\"> button</span><span style=\"--shiki-dark:#F97583;--shiki-light:#D73A49\"> =</span><span style=\"--shiki-dark:#9ECBFF;--shiki-light:#032F62\"> \"primary\"</span><span style=\"--shiki-dark:#F97583;--shiki-light:#D73A49\"> as</span><span style=\"--shiki-dark:#F97583;--shiki-light:#D73A49\"> const</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">; </span><span style=\"--shiki-dark:#6A737D;--shiki-light:#6A737D\">// 타입: \"primary\"</span></span></code></pre></figure>\n<p>배열이나 객체에 쓰면 해당 구조를 읽기 전용(readonly)으로 만들면서 각 요소의 타입을 리터럴로 고정한다.</p>\n<figure data-rehype-pretty-code-figure=\"\"><pre tabindex=\"0\" data-language=\"ts\" data-theme=\"github-dark github-light\"><code data-language=\"ts\" data-theme=\"github-dark github-light\" style=\"display: grid;\"><span data-line=\"\"><span style=\"--shiki-dark:#F97583;--shiki-light:#D73A49\">const</span><span style=\"--shiki-dark:#79B8FF;--shiki-light:#005CC5\"> status</span><span style=\"--shiki-dark:#F97583;--shiki-light:#D73A49\"> =</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\"> [</span><span style=\"--shiki-dark:#9ECBFF;--shiki-light:#032F62\">\"idle\"</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">, </span><span style=\"--shiki-dark:#9ECBFF;--shiki-light:#032F62\">\"loading\"</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">] </span><span style=\"--shiki-dark:#F97583;--shiki-light:#D73A49\">as</span><span style=\"--shiki-dark:#F97583;--shiki-light:#D73A49\"> const</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">;</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#6A737D;--shiki-light:#6A737D\">// 타입: readonly [\"idle\", \"loading\"]</span></span></code></pre></figure>\n<p>이처럼 <strong>값을 변경 불가능한 상수로 명시</strong>하고, 타입도 좁게 고정되도록 만드는 것이 핵심이다.</p>\n<hr>\n<h3 id=\"tanstack-query--query-key-안정성-확보\"><a class=\"anchor\" href=\"#tanstack-query--query-key-안정성-확보\">TanStack Query – query key 안정성 확보</a></h3>\n<figure data-rehype-pretty-code-figure=\"\"><pre tabindex=\"0\" data-language=\"ts\" data-theme=\"github-dark github-light\"><code data-language=\"ts\" data-theme=\"github-dark github-light\" style=\"display: grid;\"><span data-line=\"\"><span style=\"--shiki-dark:#F97583;--shiki-light:#D73A49\">const</span><span style=\"--shiki-dark:#79B8FF;--shiki-light:#005CC5\"> queryKey</span><span style=\"--shiki-dark:#F97583;--shiki-light:#D73A49\"> =</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\"> [</span><span style=\"--shiki-dark:#9ECBFF;--shiki-light:#032F62\">\"user\"</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">, userId] </span><span style=\"--shiki-dark:#F97583;--shiki-light:#D73A49\">as</span><span style=\"--shiki-dark:#F97583;--shiki-light:#D73A49\"> const</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">;</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#B392F0;--shiki-light:#6F42C1\">useQuery</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">({ queryKey, queryFn });</span></span></code></pre></figure>\n<p>여기서 <code>as const</code>를 쓰지 않으면 queryKey는 <code>(string | number)[]</code>로 추론되어 타입 안정성이 떨어진다.</p>\n<p>반면 <code>as const</code>를 쓰면 queryKey가 정확히 <code>readonly [\"user\", string]</code>이 되어, <strong>query key가 고정된 식별자로 취급</strong>되고, 캐싱/비교/인밸리데이션에서도 더 안정적으로 작동한다.</p>\n<hr>\n<h3 id=\"react-router--라우팅과-같은-객체-구조의-키값-고정\"><a class=\"anchor\" href=\"#react-router--라우팅과-같은-객체-구조의-키값-고정\">React Router – 라우팅과 같은 객체 구조의 키값 고정</a></h3>\n<figure data-rehype-pretty-code-figure=\"\"><pre tabindex=\"0\" data-language=\"ts\" data-theme=\"github-dark github-light\"><code data-language=\"ts\" data-theme=\"github-dark github-light\" style=\"display: grid;\"><span data-line=\"\"><span style=\"--shiki-dark:#F97583;--shiki-light:#D73A49\">const</span><span style=\"--shiki-dark:#79B8FF;--shiki-light:#005CC5\"> router</span><span style=\"--shiki-dark:#F97583;--shiki-light:#D73A49\"> =</span><span style=\"--shiki-dark:#B392F0;--shiki-light:#6F42C1\"> createBrowserRouter</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">([</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">  { path: </span><span style=\"--shiki-dark:#9ECBFF;--shiki-light:#032F62\">\"/home\"</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">, element: &#x3C;</span><span style=\"--shiki-dark:#B392F0;--shiki-light:#6F42C1\">HomePage</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\"> /> },</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">  { path: </span><span style=\"--shiki-dark:#9ECBFF;--shiki-light:#032F62\">\"/about\"</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">, element: &#x3C;</span><span style=\"--shiki-dark:#B392F0;--shiki-light:#6F42C1\">AboutPage</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\"> /> }</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">] </span><span style=\"--shiki-dark:#F97583;--shiki-light:#D73A49\">as</span><span style=\"--shiki-dark:#F97583;--shiki-light:#D73A49\"> const</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">);</span></span></code></pre></figure>\n<p>React Router는 내부적으로 라우트 배열을 순회하면서 타입을 추론하려고 하기 때문에, <code>as const</code>로 선언해주면 각 path의 리터럴 값(<code>\"/home\"</code>, <code>\"/about\"</code>)을 정확히 추론할 수 있다.</p>\n<p>이를 통해 <strong>라우트 기반 자동완성, 타입 기반 네비게이션 제어</strong>가 가능해진다.</p>\n<hr>\n<h2 id=\"as-const를-쓰지-않아야-할-때\"><a class=\"anchor\" href=\"#as-const를-쓰지-않아야-할-때\"><code>as const</code>를 쓰지 않아야 할 때</a></h2>\n<p>무조건 좁은 타입이 좋은 건 아니다. 다음과 같은 경우는 오히려 <code>as const</code>를 쓰지 않는 것이 낫다.</p>\n<figure data-rehype-pretty-code-figure=\"\"><pre tabindex=\"0\" data-language=\"ts\" data-theme=\"github-dark github-light\"><code data-language=\"ts\" data-theme=\"github-dark github-light\" style=\"display: grid;\"><span data-line=\"\"><span style=\"--shiki-dark:#F97583;--shiki-light:#D73A49\">let</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\"> status </span><span style=\"--shiki-dark:#F97583;--shiki-light:#D73A49\">=</span><span style=\"--shiki-dark:#9ECBFF;--shiki-light:#032F62\"> \"idle\"</span><span style=\"--shiki-dark:#F97583;--shiki-light:#D73A49\"> as</span><span style=\"--shiki-dark:#F97583;--shiki-light:#D73A49\"> const</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">;</span></span></code></pre></figure>\n<p>이렇게 하면 <code>status</code>는 절대 다른 문자열을 가질 수 없기 때문에, 동적으로 상태를 변경해야 하는 경우엔 적절치 않다.</p>\n<hr>\n<figure data-rehype-pretty-code-figure=\"\"><pre tabindex=\"0\" data-language=\"ts\" data-theme=\"github-dark github-light\"><code data-language=\"ts\" data-theme=\"github-dark github-light\" style=\"display: grid;\"><span data-line=\"\"><span style=\"--shiki-dark:#F97583;--shiki-light:#D73A49\">function</span><span style=\"--shiki-dark:#B392F0;--shiki-light:#6F42C1\"> update</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">(</span><span style=\"--shiki-dark:#FFAB70;--shiki-light:#E36209\">type</span><span style=\"--shiki-dark:#F97583;--shiki-light:#D73A49\">:</span><span style=\"--shiki-dark:#9ECBFF;--shiki-light:#032F62\"> \"create\"</span><span style=\"--shiki-dark:#F97583;--shiki-light:#D73A49\"> |</span><span style=\"--shiki-dark:#9ECBFF;--shiki-light:#032F62\"> \"delete\"</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">) {}</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#B392F0;--shiki-light:#6F42C1\">update</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">(</span><span style=\"--shiki-dark:#9ECBFF;--shiki-light:#032F62\">\"create\"</span><span style=\"--shiki-dark:#F97583;--shiki-light:#D73A49\"> as</span><span style=\"--shiki-dark:#F97583;--shiki-light:#D73A49\"> const</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">); </span><span style=\"--shiki-dark:#6A737D;--shiki-light:#6A737D\">// 불필요</span></span></code></pre></figure>\n<p>함수 시그니처가 리터럴 타입을 받는 경우, 이미 문자열 리터럴을 넣으면 타입이 자동으로 좁혀진다. 명시적 <code>as const</code>는 오히려 코드만 장황해질 수 있다.</p>\n<hr>\n<h2 id=\"내부-동작-원리--const-assertion의-타입화\"><a class=\"anchor\" href=\"#내부-동작-원리--const-assertion의-타입화\">내부 동작 원리 – const assertion의 타입화</a></h2>\n<p>TypeScript에서 <code>as const</code>는 해당 값은 <strong>readonly</strong>로 간주되고, 가능한 한 좁은 타입으로 <strong>리터럴 추론</strong>을 한다.</p>\n<figure data-rehype-pretty-code-figure=\"\"><pre tabindex=\"0\" data-language=\"ts\" data-theme=\"github-dark github-light\"><code data-language=\"ts\" data-theme=\"github-dark github-light\" style=\"display: grid;\"><span data-line=\"\"><span style=\"--shiki-dark:#F97583;--shiki-light:#D73A49\">const</span><span style=\"--shiki-dark:#79B8FF;--shiki-light:#005CC5\"> obj</span><span style=\"--shiki-dark:#F97583;--shiki-light:#D73A49\"> =</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\"> { a: </span><span style=\"--shiki-dark:#79B8FF;--shiki-light:#005CC5\">1</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">, b: </span><span style=\"--shiki-dark:#9ECBFF;--shiki-light:#032F62\">\"x\"</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\"> } </span><span style=\"--shiki-dark:#F97583;--shiki-light:#D73A49\">as</span><span style=\"--shiki-dark:#F97583;--shiki-light:#D73A49\"> const</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">;</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#6A737D;--shiki-light:#6A737D\">// 타입: { readonly a: 1; readonly b: \"x\"; }</span></span></code></pre></figure>\n<p>이는 일종의 <strong>const assertion</strong>으로, 값 자체는 JS에서 변하지 않지만 타입도 함께 고정시키는 것이 특징이다.</p>\n<p>배열, 객체, 튜플 등에 모두 적용 가능하며, <strong>유형 안정성(type safety)을 명시적으로 선언하는 수단</strong>이다.</p>\n<hr>\n<h3 id=\"기술적으로-조금-더-깊게-들어가면\"><a class=\"anchor\" href=\"#기술적으로-조금-더-깊게-들어가면\">기술적으로 조금 더 깊게 들어가면</a></h3>\n<p>TypeScript는 <code>as const</code>를 만나면 해당 값 전체를 readonly로 처리하며, 내부 속성 하나하나를 리터럴 타입으로 고정한다.</p>\n<p>이는 내부적으로 <code>const T: { readonly a: 1, readonly b: \"x\" }</code> 같은 형태로 변환된다.</p>\n<p>제네릭 함수에서 <code>as const</code>된 인자를 넘기면, 추론된 타입이 정확한 리터럴 형태로 유지되기 때문에 타입 제한, 자동완성, 추론 정확도가 크게 향상된다.</p>\n<p>특히 readonly 튜플로 바뀐다는 점에서, 배열 기반 추론(예: query key 등)에 매우 큰 이점을 준다.</p>\n<figure data-rehype-pretty-code-figure=\"\"><pre tabindex=\"0\" data-language=\"ts\" data-theme=\"github-dark github-light\"><code data-language=\"ts\" data-theme=\"github-dark github-light\" style=\"display: grid;\"><span data-line=\"\"><span style=\"--shiki-dark:#F97583;--shiki-light:#D73A49\">const</span><span style=\"--shiki-dark:#79B8FF;--shiki-light:#005CC5\"> key</span><span style=\"--shiki-dark:#F97583;--shiki-light:#D73A49\"> =</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\"> [</span><span style=\"--shiki-dark:#9ECBFF;--shiki-light:#032F62\">\"user\"</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">, </span><span style=\"--shiki-dark:#79B8FF;--shiki-light:#005CC5\">1</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">] </span><span style=\"--shiki-dark:#F97583;--shiki-light:#D73A49\">as</span><span style=\"--shiki-dark:#F97583;--shiki-light:#D73A49\"> const</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">;</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#F97583;--shiki-light:#D73A49\">type</span><span style=\"--shiki-dark:#B392F0;--shiki-light:#6F42C1\"> Key</span><span style=\"--shiki-dark:#F97583;--shiki-light:#D73A49\"> =</span><span style=\"--shiki-dark:#F97583;--shiki-light:#D73A49\"> typeof</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\"> key; </span><span style=\"--shiki-dark:#6A737D;--shiki-light:#6A737D\">// readonly [\"user\", 1]</span></span></code></pre></figure>\n<p>만약 <code>as const</code> 없이 선언했다면 <code>Key</code>는 <code>(string | number)[]</code>이 되었을 것이고, 타입 정합성은 깨졌을 것이다.</p>\n<hr>\n<h2 id=\"enum과-비슷하지만-다르다\"><a class=\"anchor\" href=\"#enum과-비슷하지만-다르다\"><code>enum</code>과 비슷하지만 다르다.</a></h2>\n<p><code>as const</code>와 <code>enum</code>은 모두 <strong>값 집합을 고정시키는</strong> 용도로 사용되지만, 아래와 같은 차이가 있다.</p>\n<hr>\n<p>| 항목           | <code>as const</code>  | <code>enum</code>        |\n| ------------ | ----------- | ------------- |\n| 런타임 존재 여부    | 값 그 자체      | 객체 생성됨        |\n| 타입 유추 방식     | 리터럴 타입으로 추론 | 명시적 타입 선언 필요  |\n| Tree-shaking | 가능          | 어려움           |\n| JS 출력 코드     | 없음          | 존재 (실제 객체 생성) |</p>\n<figure data-rehype-pretty-code-figure=\"\"><pre tabindex=\"0\" data-language=\"ts\" data-theme=\"github-dark github-light\"><code data-language=\"ts\" data-theme=\"github-dark github-light\" style=\"display: grid;\"><span data-line=\"\"><span style=\"--shiki-dark:#F97583;--shiki-light:#D73A49\">type</span><span style=\"--shiki-dark:#B392F0;--shiki-light:#6F42C1\"> Mode</span><span style=\"--shiki-dark:#F97583;--shiki-light:#D73A49\"> =</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\"> (</span><span style=\"--shiki-dark:#F97583;--shiki-light:#D73A49\">typeof</span><span style=\"--shiki-dark:#79B8FF;--shiki-light:#005CC5\"> MODES</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">)[</span><span style=\"--shiki-dark:#79B8FF;--shiki-light:#005CC5\">number</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">];</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"--shiki-dark:#F97583;--shiki-light:#D73A49\">const</span><span style=\"--shiki-dark:#79B8FF;--shiki-light:#005CC5\"> MODES</span><span style=\"--shiki-dark:#F97583;--shiki-light:#D73A49\"> =</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\"> [</span><span style=\"--shiki-dark:#9ECBFF;--shiki-light:#032F62\">\"light\"</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">, </span><span style=\"--shiki-dark:#9ECBFF;--shiki-light:#032F62\">\"dark\"</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">] </span><span style=\"--shiki-dark:#F97583;--shiki-light:#D73A49\">as</span><span style=\"--shiki-dark:#F97583;--shiki-light:#D73A49\"> const</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">;</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"--shiki-dark:#F97583;--shiki-light:#D73A49\">enum</span><span style=\"--shiki-dark:#B392F0;--shiki-light:#6F42C1\"> ModeEnum</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\"> {</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#79B8FF;--shiki-light:#005CC5\">  Light</span><span style=\"--shiki-dark:#F97583;--shiki-light:#D73A49\"> =</span><span style=\"--shiki-dark:#9ECBFF;--shiki-light:#032F62\"> \"light\"</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">,</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#79B8FF;--shiki-light:#005CC5\">  Dark</span><span style=\"--shiki-dark:#F97583;--shiki-light:#D73A49\"> =</span><span style=\"--shiki-dark:#9ECBFF;--shiki-light:#032F62\"> \"dark\"</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">}</span></span></code></pre></figure>\n<p>대부분의 경우 <strong>불필요한 런타임 비용 없이 타입만 고정하고 싶을 때는 <code>as const</code>가 더 효율적</strong>이다.</p>\n<figure data-rehype-pretty-code-figure=\"\"><pre tabindex=\"0\" data-language=\"toc\" data-theme=\"github-dark github-light\"><code data-language=\"toc\" data-theme=\"github-dark github-light\" style=\"display: grid;\"><span data-line=\"\"> </span></code></pre></figure>"
  },
  "_id": "250620/index.md",
  "_raw": {
    "sourceFilePath": "250620/index.md",
    "sourceFileName": "index.md",
    "sourceFileDir": "250620",
    "contentType": "markdown",
    "flattenedPath": "250620"
  },
  "type": "Post",
  "slug": "/250620",
  "categoryArray": [
    "프론트엔드",
    "TypeScript"
  ],
  "readingTime": "7 min read",
  "excerpt": "프론트엔드 실무에서 as const를 단순히 타입 추론을 돕는 보조 수단이 아니라, 불변성 선언과 동시에 타입의 리터럴화를 통해 안정성과 자동완성을 극대화할 수 있는 툴로 유용하게 사용하고 있다. 이번 글에서는 실무에서 as const의 활용 사례를 중심으로 활용과 원리까지 깊이 있게 다뤄보려 한다. as const as const는 TypeScript에서..."
}