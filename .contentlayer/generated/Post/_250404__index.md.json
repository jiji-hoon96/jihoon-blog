{
  "title": "Verdaccio와 Lerna를 활용한 사내 유틸리티 라이브러리 구축기",
  "date": "2025-04-04T00:00:00.000Z",
  "categories": "프론트엔드 인프라",
  "body": {
    "raw": "\n회사 내에서 프론트엔드 공통 유틸리티 모듈을 통합 관리하는 작업을 맡으면서, 다음과 같은 요구사항이 생겼다.\n\n- 여러 레포지토리에 중복된 로직을 하나로 추출해 관리하고 싶다.\n- 패키지 단위로 분리해 모노레포 형태로 운영하되, 유연한 버전 관리가 필요하다.\n- 외부 공개 없이 사내에서만 배포 및 사용 가능한 NPM 패키지 레지스트리를 갖추고 싶다.\n- CI/CD 파이프라인에서도 안전하고 빠르게 배포되도록 자동화를 고려해야 한다.\n\n이 문제를 해결하기 위해 선택한 조합이 바로 `Lerna`와 `Verdaccio`다.\n\nLerna는 모노레포에서 패키지를 효과적으로 분리하고, 빌드/배포 파이프라인을 정리하는 데 탁월하다. \n\n특히 **independent versioning 전략**을 활용하면 각 패키지의 변경사항만 추적하여 배포할 수 있어 유틸리티성 모듈 관리에 적합하다.\n\n반면, Verdaccio는 사내 전용 NPM 레지스트리를 손쉽게 구축할 수 있는 도구로, 설정이 단순하며, Docker 기반으로 격리된 레지스트리를 운영할 수 있다. npmjs.org와의 proxy 연결도 가능해, 공용 패키지를 사내 캐싱하는 역할까지 수행할 수 있다.\n\n이 글에서는 단순한 튜토리얼이 아닌, 실제 구축 경험을 바탕으로 **설계 의도, 구조 구성, 보안 전략, 자동화 배포 흐름**까지 기술적으로 깊게 다뤄볼 예정이다.\n\n---\n\n### 기술 선택의 이유\n\n사내 유틸리티 라이브러리의 특성상, 아래와 같은 구조가 필요했다.\n\n- 프로젝트 간 코드 중복 제거 (ex. date formatter, error handler, toast utils 등)\n- 빌드 후 개별 패키지로 publish, 각 프로젝트에서 scoped import로 사용\n- 사내 프라이빗 레지스트리로 퍼블리싱 (Verdaccio)\n- 자동화 배포 스크립트 (Lerna + Git tag 기반 publish)\n\n이를 고려했을 때 `Turborepo`, `Nx` 같은 최신 도구도 고려했지만,\n\n- Nx는 workspace 내 모든 패키지가 동일한 버전 관리 체계를 요구하거나, monolithic CI 구조가 필요한 경우 더 적합하다고 생각\n- Lerna는 더 유연한 버전 전략을 제공하고, 다양한 팀이 패키지를 독립적으로 운영할 수 있게 도와줌\n- Verdaccio는 자체 인증과 스코프 제어를 통한 접근 제어가 가능\n\n그렇기에 Lerna + Verdaccio가 현재 상황에서 가장 합리적인 선택이었다.\n\n\n---\n\n---\n\n---\n\n## Lerna 기반 모노레포 아키텍처 구성\n\n사내 유틸리티 라이브러리는 장기적으로 확장 가능하고 모듈화된 구조여야 했다. \n\n단순히 공통 함수들을 모아두는 수준을 넘어서, 각기 다른 목적의 기능들이 하나의 레포 안에서 독립적으로 유지보수 가능해야 했기 때문이다.\n\n그래서 도입한 구조가 바로 `Lerna` 기반의 모노레포 아키텍처였다.\n\n---\n\n### 모노레포 패키지 구조 설계\n\n모노레포에는 현재 두 개의 주요 패키지가 존재한다.\n\n- `@company/common-library`: 날짜 파싱, 타입 헬퍼, 유효성 검사 등 다양한 프론트엔드 프로젝트에서 재사용되는 범용 유틸리티 모듈\n- `@company/napi`: 내부 시스템과 연동되는 네이티브 API wrapper 혹은 RPC 클라이언트 역할의 모듈\n\n이런 구조를 통해 **도메인 별 패키지 책임을 분리하면서도**, 공통 코드베이스 안에서 통합 관리가 가능하도록 구성했다.\n\n```\npackages/\n├── company-common-library/\n├── company-napi/\n```\n\n패키지들은 모두 `packages/` 디렉토리 하위에 존재하며, 각각 독립적인 `package.json`, 빌드, 테스트 환경을 가진다.\n\n<br/>\n\n### Lerna 설정 (`lerna.json`)과 버전 관리\n\n```json\n{\n  \"version\": \"independent\",\n  \"packages\": [\"packages/*\"],\n  \"npmClient\": \"pnpm\"\n}\n```\n\nLerna는 기본적으로 두 가지 버전 전략을 지원한다\n\n- **fixed 모드** : 모든 패키지가 같은 버전으로 관리됨\n- **independent 모드** : 패키지별로 독립적인 버전 관리\n\n우리는 `independent` 모드를 선택했는데, 이 전략에서는 다음과 같은 방식으로 버전이 관리된다.\n\n- `lerna publish` 실행 시, git 히스토리를 기준으로 각 패키지별 변경 여부를 분석\n- 변경이 감지된 패키지만 대상으로 `patch`, `minor`, `major` 중 하나로 버전 증가\n- 해당 패키지의 `package.json` 버전을 올리고, 태그를 각각 생성\n- 결과적으로 버전은 다음처럼 분기될 수 있다\n\n```json\ncompany-common-library@1.0.0\ncompany-napi@1.0.0\n```\n\n이렇게 하게 되면 변경되지 않은 패키지를 불필요하게 배포하지 않아도 되고, 공통 유틸리티와 도메인별 모듈 간 릴리즈 흐름 분리가 쉬우며, 팀 간 병렬적인 개발/배포가 가능하다.\n\n`independent` 버전 전략에서는 각 패키지가 독립적으로 버전 업되기 때문에, **패키지 간 참조 관계**에 주의가 필요하다.  \n\n예를 들어 `@company/common-library`를 사용하는 `@company/napi`가 있을 경우, common-library가 새로 릴리즈되더라도, napi가 참조하는 버전 범위에 해당하지 않으면 업데이트가 반영되지 않는다.\n\n이를 방지하기 위해서는 다음 두 가지를 고려해볼 수 있다.\n\n--- \n\n#### Version Range 설정 (`^`, `~`, etc.)\n\n보통 `^1.0.0`과 같이 major version 범위 내에서 자동 업데이트를 허용하는 방식이 사용된다.\n이는 common-library가 `1.0.0 → 1.2.3`으로 변경되어도 napi가 자동으로 최신 버전을 참조할 수 있게 한다.\n하지만 `1.0.0 → 2.0.0` 같은 breaking change는 자동으로 반영되지 않도록 막는다.\n\n---\n\n#### CI 테스트와 통합 빌드 검증\n\n버전이 올라간 패키지가 다른 패키지에 영향을 주는 경우, 의존 패키지에서도 함께 테스트해야 한다.\n\nCI 파이프라인에서는 전체 workspace를 대상으로 테스트를 실행하거나, **Lerna의 affected strategy (--since, --scope)를** 활용해 영향받는 패키지만 테스트하는 것도 방법이다.\n\n여기서 Lerna의 affected strategy는 변경된 패키지에 대해서만 작업을 수행하기 위한 전략을 의미한다. `--since` 옵션을 통해 지정된 Git ref 이후 변경된 패키지에만 명령 적용할 수 있고, `--scope` 옵션을 통해 특정 패키지에만 명령을 적용할 수 있다. \n\n<br/>\n\n### pnpm workspace와의 연동\n\n`package.json` 루트에서는 `workspaces` 설정을 통해 pnpm과 Lerna의 패키지 인식 범위를 통일했다.\n\n```json\n\"workspaces\": [\n  \"packages/*\"\n]\n```\n\npnpm은 Lerna와 달리 의존성을 루트에 hoist하지 않고 `.pnpm` 디렉토리에 격리해 설치한다.  \n덕분에 패키지 간 충돌을 방지할 수 있다. 그리고 파일을 여러 위치에 **복사**하지 않고, 하나의 실제 파일을 여러 위치에서 **참조**하게 만드는 방식인 **하드링크 기반 캐싱**을 통해 빌드 속도까지 개선된다.\n\n또한 `root` 패키지를 `file:`로 의존성 선언해 내부 참조 관계를 명시적으로 설정하였다\n\n```json\n\"devDependencies\": {\n  \"root\": \"file:../../\"\n}\n```\n\n<br/>\n\n### 패키지별 빌드 전략과 타입 관리\n\n각 패키지는 vite + tsc 조합으로 빌드된다.\n\n공통 모듈은 vite로 번들링된 ESM을 export하고, 동시에 `dts-bundle-generator`를 사용해 모든 타입 정의를 하나의 .d.ts 파일로 정리한다.\n\n```json\n\"build\": \"del-cli build/**/* && tsc && vite build && dts-bundle-generator ...\"\n```\n\ndts-bundle-generator 이란?\n  - TypeScript로 작성된 라이브러리를 외부에 제공할 때, 여러 개의 .d.ts 파일 대신 하나의 진입점 타입 파일을 생성해주는 도구\n  - 내부적으로 모든 타입 의존성을 분석해 export 기준으로 병합\n  - 타입만 사용하는 외부 라이브러리(zod, type-fest 등)는 inline 방식으로 포함 가능\n  - IDE에서 자동 완성, 타입 추론이 명확해지고, 사용자 입장에서도 import가 간결해지게 한다\n\n<br/>\n\n`exports` 필드는 타입, 브라우저, 기본 엔트리를 명시적으로 구분해 다양한 런타임에서도 타입 추론이 정확히 동작하도록 구성했다\n\n```json\n\"exports\": {\n  \".\": {\n    \"types\": \"./dist/company-common-library.d.ts\", // TypeScript에서 import 시 참조할 타입 선언 파일\n    \"browser\": \"./dist/company-common-library.js\", // 브라우저 번들 환경에서 우선적으로 참조할 모듈\n    \"default\": \"./dist/company-common-library.js\" // 기타 환경(Node.js 등)에서 사용할 기본 모듈\n  }\n}\n```\n\nNode.js 13 이상에서는 exports 필드를 통해 **패키지 외부에서 import 가능한 경로를 명시적으로 제한**할 수 있다. 이는 단순히 entry point를 설정하는 게 아니라, 내부 파일 구조를 외부에 노출하지 않도록 보호하는 기능이기도 하다.\n\n예를 들어 위 설정에서는 아래처럼만 import가 가능하고,\n\n```ts\nimport { formatDate } from '@company/common';\n```\n\n직접 경로 접근은 불가능하다\n\n```ts\n// ❌ ERR_PACKAGE_PATH_NOT_EXPORTED 오류 발생\nimport { formatDate } from '@company/common/utils/format';\n```\n\n\n<br/>\n\n### 테스트와 커버리지 전략\n\n유닛 테스트는 `vitest`로 작성되며, 공통 유틸 함수의 안정성과 리팩토링을 보장하기 위한 커버리지를 기본으로 포함했다.\n\n```json\n\"scripts\": {\n  \"test\": \"vitest\",\n  \"test:coverage\": \"vitest --coverage\"\n}\n```\n\n`__tests__/`와 `__bench__/` 디렉토리는 기능 테스트 외에도 퍼포먼스 비교 테스트를 병행하도록 설계되었다.  \n이는 내부 util 함수들 간 병목 현상 탐지를 위한 구조이며, 런타임 성능 개선을 정량적으로 추적할 수 있게 한다.\n\n\n\n--- \n\n\n## Verdaccio 기반 프라이빗 NPM 레지스트리 구축\n\n앞선 글에서 Lerna 기반의 모노레포 아키텍처를 통해 공통 유틸리티 라이브러리를 패키지 단위로 관리하는 구조를 살펴보았다. \n\n하지만 이를 실제로 배포하고 사용할 수 있으려면 내부 전용 NPM 레지스트리가 필요하다.\n\n<br/>\n\n### 왜 내부 전용이어야 했을까?\n\n우리가 관리하는 유틸리티 패키지에는 비즈니스 로직이 직접 담기지 않더라도, **사내 시스템 구조나 네이밍, 유효성 규칙** 등 외부에 노출되면 민감할 수 있는 내부 도메인 정보가 간접적으로 포함된다. \n\n또한, 사내 환경에 최적화된 설정 및 인터페이스를 포함하고 있기 때문에, 외부 레지스트리(NPM public registry)에서 공개적으로 운영하는 것이 적절하지 않다.\n\n무엇보다도 외부 패키지와의 **네이밍 충돌이나 dependency confusion** 같은 공격 벡터를 차단하기 위해, 스코프가 명확히 정의된 사설 레지스트리를 통해 관리하는 것이 더 안전하고 예측 가능하다.\n\n외부에 공개되지 않고, CI/CD와 연계되며, 접근 제어가 가능한 프라이빗 레지스트리를 구축하는 데 가장 적합한 도구는 바로 **Verdaccio**였다.\n\nVerdaccio는 경량화된 Node.js 기반 NPM registry로, 손쉽게 설치하고 구성할 수 있으며, Docker 환경과도 잘 통합된다.\n\n<br/>\n\n### Docker 기반 레지스트리 인프라 구성\n\n사내 인프라에는 다음과 같은 형태로 `verdaccio` 인스턴스를 구성하였다:\n\n```yaml\n# docker-compose.yml\nversion: '3.7'\n\nservices:\n  verdaccio:\n    image: hub.docker.company.net/verdaccio\n    container_name: verdaccio\n    restart: always\n    environment:\n      - VERDACCIO_PORT=COMPANY_PORT\n    ports:\n      - COMPANY_PORT=PORT\n    volumes:\n      - storage:/verdaccio/storage\n    networks:\n      - verdaccio_bridge\n\nvolumes:\n  storage:\n\nnetworks:\n  verdaccio_bridge:\n    driver: bridge\n```\n\n- `COMPANY_PORT`를 통해 외부 접근을 제공\n- `storage` 볼륨을 분리해 캐시 및 패키지 데이터를 지속성하게 저장\n- `verdaccio_bridge`를 통해 다른 사내 서비스와 연동 가능하도록 네트워크 분리\n\n<br/>\n\n#### 그럼 왜 별도의 네트워크(`verdaccio_bridge`)를 사용할까?\n\nDocker Compose에서 `networks`를 명시적으로 분리한 이유는 **사내 서비스 간 통신 경계를 제어하고 보안을 강화하기 위함**이다.\n\n- `verdaccio`는 단일 독립 서비스가 아니라, CI/CD 서버, 릴리즈 빌더, 테스트 실행기 등 다양한 사내 컨테이너와 상호 작용하게 된다.\n- `verdaccio_bridge`라는 브릿지 네트워크에 연결된 서비스들만 `http://verdaccio:PORT` 형태로 내부 통신이 가능하다.\n- 외부에서의 접근은 오직 공개 포트(COMPANY_PORT)를 통해서만 가능하며, 내부 접근은 명시적으로 네트워크에 연결된 컨테이너로 제한된다.\n\n<br/>\n\n이 구조는 다음과 같은 효과를 제공한다\n\n| 목적 | 효과 |\n|------|------|\n| 내부 통신 제한 | 의도된 컨테이너 간 연결만 허용 (예: CI만 verdaccio에 접근 가능) |\n| 보안 강화 | 외부로부터 직접 접근을 막고, 네트워크 구간을 논리적으로 분리 |\n| 운영 유연성 | 환경별로 독립된 레지스트리 환경 구성 가능 (dev, staging, prod) |\n\n결국 Verdaccio가 포함된 도커 네트워크를 분리함으로써, 단순한 패키지 저장소 이상의 **통제 가능한 사내 배포 허브**로 기능하게 된다.\n\n---\n\n### 설정 파일 구조 및 접근 제어\n\n핵심 설정은 `config.yaml`로 관리된다. 주요 설정 포인트는 다음과 같다\n\n```yaml\nstorage: /verdaccio/storage\nurl_prefix: /npm/\n\nauth:\n  htpasswd:\n    file: /verdaccio/conf/htpasswd\n\npackages:\n  '@company/*':\n    access: $authenticated\n    publish: $authenticated\n\n  '**':\n    access: $all\n    publish: $authenticated\n    proxy: npmjs\n```\n\n#### 주요 포인트\n\n- `@company/*` 스코프 패키지에 대해서는 인증된 사용자만 publish/read 가능하도록 설정\n- `proxy: npmjs` 설정으로, 사내 캐싱 기능과 fallback 지원\n- `url_prefix` 를 `/npm/`으로 설정해 nginx 리버스 프록시 또는 CI 내부에서 명확한 경로 관리 가능\n- 인증은 `htpasswd` 기반으로 구성하며, 사용자 수 제한 및 bcrypt 암호화도 설정 가능\n\n<br/>\n\n#### 인증(htpasswd)은 어떻게 동작할까?\n\nauth.htpasswd 설정은 기본적인 HTTP 인증 기반으로 작동하며, htpasswd 파일은 `사용자명:해시된 패스워드` 형태로 저장된다.\n이때 사용되는 해시는 bcrypt이며, 패스워드 보안성과 저장 구조가 단순한 텍스트 인증보다 훌씬 안전하다.\n\n- 사용자 추가는 CLI 또는 직접 생성 가능\n- publish, install 시 HTTP Authorization 헤더로 인증이 수행됨\n- CI 환경에서는 npm login 또는 NPM_TOKEN으로 자동 처리 가능\n- 사용자 수가 많아질 경우 LDAP, OAuth 등의 외부 인증 연동 플러그인도 존재함\n\n<br/>\n\n#### 프록시(proxy)는 언제 동작하는가?\n\nVerdaccio의 proxy 설정은 해당 패키지가 로컬(storage)에 존재하지 않을 때만 외부 registry로 요청을 전달한다.\n이 기능을 통해 사내에서 외부 패키지를 설치하더라도, 최초 요청 이후에는 로컬 캐시에 저장되므로 성능이 향상된다.\n\n- `proxy: npmjs`는 uplink로 https://registry.npmjs.org를 의미\n- 최초 요청 시 메타정보와 .tgz 파일이 /storage 디렉토리에 캐싱됨\n- 동일 요청은 외부 네트워크 없이 캐시에서 처리됨\n\n---\n\n### 보안을 고려한 운영 전략\n\n프라이빗 레지스트리는 종종 **dependency confusion**과 같은 공격에 노출될 수 있다. 이를 방지하기 위해 다음과 같은 정책을 적용했다\n\n| 설정 항목 | 목적 |\n|----------|------|\n| `proxy` 제거 (특정 스코프에 대해) | 외부 npmjs로 fallback 막기 |\n| `publish` 제한 | 인증된 사용자만 업로드 가능 |\n| `unpublish` 제한 | 과거 버전 삭제 불가하도록 설정 |\n| `middlewares.audit.enabled: true` | 감사 로그 기록 활성화 |\n| Docker 내부 포트 비공개 | 외부 접근은 특정 게이트웨이에서만 허용 |\n\n@company/* 같이 사내 전용 스코프에는 프록시를 명시적으로 비활성화하는 것이 권장되고 있다.\n\n또한 Verdaccio와 proxy 조합에서는 스코프 전략과 외부 fallback 경로를 명확하게 구분하는 것이 중요하다.\n\n<br/>\n\n### 퍼블리시 및 연동 흐름\n\n패키지 publish는 다음과 같은 명령어 흐름으로 구성된다:\n\n```bash\npnpm build\nnpm set registry http://verdaccio.company.net:COMPANY_PORT/npm/\nnpm login\nlerna publish patch --yes\n```\n\n- `lerna publish`는 각 변경된 패키지에 대해 독립적으로 버전 증가 및 배포\n- `registry` 설정을 통해 verdaccio에 publish가 가능하도록 한다\n- CI/CD에서는 `NPM_TOKEN`을 활용해 자동 로그인 처리\n\n---\n\n\nVerdaccio를 통해 빠르고 간편하게 프라이빗 레지스트리를 구축할 수 있었다. 추가로 보안 설정과 proxy 전략을 적절히 조합하여, dependency confusion을 효과적으로 방지할 수 있었다.\n\n향후에는 OAuth 기반 인증, Web UI 비활성화, nginx 리버스 프록시 연동 등으로 보안 강화를 고민해봐도 좋을것 같다.\n\n\n---\n\n## semantic-release 도입 배경\n\n\n앞선 챕터에서는 `Lerna` 기반 모노레포와 `Verdaccio` 프라이빗 레지스트리 인프라 구성을 다루었다. 이제 이 구조가 실질적으로 작동하기 위해서는 **버전 관리 및 배포 흐름의 자동화**가 필요하다.\n\n\n특히 사내 라이브러리의 특성상 배포가 자주 발생하고, 사람이 직접 `lerna publish`에 버전 인자를 입력해 버전 번호를 관리하는 것은 실수의 여지가 크다. 또한 변경 없는 패키지까지 함께 publish 되는 경우 발생하기도 하고, 버전 증가 정책이 일관되지 않음으로써 버전 관리가 어려운 상황이 발생하기도한다.\n\n그래서 semantic-release(플러그인 기반의 릴리즈 파이프라인)를 활용해 커밋 메시지를 기반으로 자동으로 버전이 관리되도록 구성했다.\n\nsemantic-release는 각 단계가 plugin으로 구성되며, release process의 각 역할(버전 계산, changelog 생성, git 태그, publish 등)을 분리된 모듈로 처리하는 특징을 가진다.\n\n기본 실행 흐름은 다음과 같다\n\n**commit-analyzer** => **release-notes-generator** => **npm** => **git** =>  github, slack, etc… (Optional)\n\n---\n\n### CI에서 semantic-release 자동 실행\n\nsemantic-release는 보통 GitHub Action 또는 GitLab CI와 함께 사용되지만, 우리는 사내 인프라를 위해 Bitbucket Pipelines를 기반으로 구성하였다.\n\n아래 예시와 같이 pipeline을 구성했다\n\n```yaml\npipelines:\n  branches:\n    main:\n      - step:\n          name: release\n          caches:\n            - node\n          script:\n            - pnpm install\n            - pnpm build\n            - pnpm semantic-release\n```\n\n- main 브랜치에 머지되면 자동으로 `semantic-release`가 실행되고\n- 커밋 메시지에 따라 버전이 증가하며, git tag가 생성되고\n- 지정된 레지스트리 (Verdaccio)로 패키지가 publish된다\n\n---\n\n### Lerna와의 통합\n\nLerna 8 버전 이후에는 자체적인 conventional commits 기반 릴리즈 지원이 강화되었으나, 우리 구성에서는 `semantic-release` 단독 사용이 아닌, 다음과 같은 역할 분담 구조를 가졌다\n\n- Lerna → 모노레포 패키지 실행 관리, build 스크립트 일괄 실행\n- semantic-release → 버전 계산 및 git tag, changelog 생성\n- pnpm → workspace 및 의존성 관리\n\n이 구조로 인해 각자의 역할이 명확하게 나뉘며, 중복 설정 없이 유지보수가 용이해졌다.\n\n---\n\nsemantic-release를 통해 다음과 같은 효과를 얻을 수 있었다\n\n- 사람이 직접 버전 관리를 하지 않아도 되어 실수 방지\n- 릴리즈 로그, git tag, changelog 자동 생성으로 배포 이력 관리 용이\n- CI 환경에서 자동 publish 흐름 구성 → 완전한 GitOps 실현\n\n이는 특히 사내 공통 라이브러리처럼 빠르게 변화하고, 여러 프로젝트에서 재사용되는 컴포넌트를 관리할 때 큰 장점을 가진다.\n\n---\n\n\n\n## Scoped 패키지란?\n\nScoped 패키지는 `@scope/name` 형태의 네이밍을 가진 NPM 패키지다.\n\n```bash\n@company/company-common-library\n@company/company-napi\n```\n\n이를 통해 다음과 같은 효과를 얻을 수 있다:\n\n- **패키지 네이밍의 네임스페이스화** → 사내 도메인 명확화\n- **프라이빗 레지스트리 내 권한 제어** (config.yaml에서 `@company/*` 스코프 제한)\n- **모듈 간 관계 파악 용이** → 범용 vs 도메인 특화 모듈 구분\n\nVerdaccio의 설정에서도 `@company/*` 에 대해 별도의 접근 및 publish 정책을 구성할 수 있어 보안/정책 관리에 적합하다.\n\n---\n\n### 서비스 프로젝트에서 설치 및 사용\n\n패키지를 사용하려는 서비스 프로젝트에서는 다음과 같이 설정한다\n\n#### `.npmrc` 구성\n\n```bash\n@company:registry=http://verdaccio.company.net:COMPANY_PORT/npm/\n//verdaccio.company.net:COMPANY_PORT/npm/:_authToken=xxxxx\n```\n\n- 특정 스코프(`@company`)만 내부 레지스트리로 리다이렉트\n- 나머지는 public npm registry를 그대로 사용\n\n이를 통해 내부 패키지는 Verdaccio에서, 외부 라이브러리는 기존 npm에서 가져오도록 이원화된 설정이 가능하다.\n\n<br/>\n\n#### 설치\n\n라이브러리는 비공개이기떄문에, 설치 예시만 보여주겠다.\n\n```bash\npnpm install @company/company-common-library\n```\n\n---\n\n### import 방식\n\nscoped 패키지로 배포된 유틸리티는 다음과 같이 프로젝트 내에서 import 가능하다:\n\n```ts\nimport { formatDate, safeParse } from '@company/company-common-library/utils/date';\nimport { buildQueryString } from '@company/company-common-library/utils/url';\n```\n\n- 경량 ESM 번들로 export되기 때문에 트리 쉐이킹에 최적화\n- 타입 정의도 함께 제공되므로 TS 프로젝트에서 타입 추론이 즉시 가능\n- IDE 자동완성 및 문서화에서 큰 이점\n\n---\n\n### 호환성과 배포 주기 전략\n\n공통 유틸리티의 경우 **주기적인 배포보다는 필요 기반의 배포 전략**을 채택했다.  \nsemantic-release가 자동으로 버전을 관리해주기 때문에, 사용처에서는 아래 전략을 따라간다\n\n- patch 업데이트는 바로 반영\n- minor 이상 업데이트는 PR에 release note 링크 포함 후 수동 반영\n- major 업데이트는 코드베이스 검토 및 팀 공유 후 채택\n\n또한 scoped 패키지는 **사내 Monorepo가 아닌 외부 레포**에서도 문제 없이 사용할 수 있다는 점이 큰 장점이다.\n\n---\n\n\n## 결론\n이번 유틸리티 라이브러리 구축 프로젝트는 단순히 패키지를 나누고 배포하는 수준을 넘어, 사내 개발 생산성, 코드 품질, 협업 효율성을 구조적으로 끌어올리기 위한 인프라 작업이었다.\n\n--- \n\n![2.png](/content/250404/2.png)\n\n--- \n\n✅ 도입을 통해 얻게 된 주요 장점\n\n- semantic-release를 통해 사람이 직접 버전 숫자를 관리하지 않아도 됨\n- Lerna + pnpm을 통해 패키지를 독립적으로 유지보수 가능\n- Verdaccio + scoped registry를 통해 외부 노출 없이 안전하게 운영\n- 단일 install로 사용 가능하며 타입 정의 및 import 구조까지 통일\n- publish → install → 반영까지 모든 흐름이 자동화되어 안정적\n\n가장 큰 장점은 **유지보수가 쉬운 아키텍처가 되었다**는 점이다. \n\n사람에 의존한 규칙이 아니라, 구조와 도구 자체가 품질과 일관성을 유지해주기 때문이다.\n\n**이러한 인프라가 갖춰졌을 때, 개발자는 더 이상 공통 로직을 복사하거나 컨벤션을 따로 전달하지 않아도 된다. 이제는 그냥 install 하면 되고, 자동으로 type도 따라온다.**\n\n--- \n\n## 앞으로의 개선 포인트\n- 전환 고려 여러 패키지에 영향을 주는 경우에는 Changesets의 PR 단위 버전 제안이 더 유리할 수도 있다고 생각해, semantic-release → Changesets 전환도 고려해볼 것 같다.\n\n- Verdaccio 인증 방식 개선 : 현재는 htpasswd 기반이지만, 사내 SSO 또는 OAuth2 연동 등 중앙 인증과 통합 가능성 검토..\n\n- 컴포넌트 단위 모듈 분리 : 현재는 유틸리티 중심이지만, 디자인 시스템이나 React 컴포넌트도 동일한 방식으로 확장 가능\n\n- 릴리즈 노트 시각화 자동화 : Slack 연동 및 Github Actions 기반 release summary 자동 게시 등 운영 효율화를 추가 검토 중.. (공수가 너무 크다)\n\n--- \n\n인프라는 결국 **개발 문화와 협업 체계의 중심**을 구성하는 것이다.\n\n처음엔 번거롭고 복잡해 보이지만, 한 번 체계를 만들어두면 이후의 유지 비용은 급격히 줄어든다.\n\n힘든 일 뒤에 보람이 온다고 했던가. 지금 와서 돌아보면, 꽤 괜찮은 경험이었다.\n\n--- \n\n![1.jpg](/content/250404/1.jpg)\n\n\n---\n\n\n```toc\n\n```",
    "html": "<p>회사 내에서 프론트엔드 공통 유틸리티 모듈을 통합 관리하는 작업을 맡으면서, 다음과 같은 요구사항이 생겼다.</p>\n<ul>\n<li>여러 레포지토리에 중복된 로직을 하나로 추출해 관리하고 싶다.</li>\n<li>패키지 단위로 분리해 모노레포 형태로 운영하되, 유연한 버전 관리가 필요하다.</li>\n<li>외부 공개 없이 사내에서만 배포 및 사용 가능한 NPM 패키지 레지스트리를 갖추고 싶다.</li>\n<li>CI/CD 파이프라인에서도 안전하고 빠르게 배포되도록 자동화를 고려해야 한다.</li>\n</ul>\n<p>이 문제를 해결하기 위해 선택한 조합이 바로 <code>Lerna</code>와 <code>Verdaccio</code>다.</p>\n<p>Lerna는 모노레포에서 패키지를 효과적으로 분리하고, 빌드/배포 파이프라인을 정리하는 데 탁월하다.</p>\n<p>특히 <strong>independent versioning 전략</strong>을 활용하면 각 패키지의 변경사항만 추적하여 배포할 수 있어 유틸리티성 모듈 관리에 적합하다.</p>\n<p>반면, Verdaccio는 사내 전용 NPM 레지스트리를 손쉽게 구축할 수 있는 도구로, 설정이 단순하며, Docker 기반으로 격리된 레지스트리를 운영할 수 있다. npmjs.org와의 proxy 연결도 가능해, 공용 패키지를 사내 캐싱하는 역할까지 수행할 수 있다.</p>\n<p>이 글에서는 단순한 튜토리얼이 아닌, 실제 구축 경험을 바탕으로 <strong>설계 의도, 구조 구성, 보안 전략, 자동화 배포 흐름</strong>까지 기술적으로 깊게 다뤄볼 예정이다.</p>\n<hr>\n<h3 id=\"기술-선택의-이유\"><a class=\"anchor\" href=\"#기술-선택의-이유\">기술 선택의 이유</a></h3>\n<p>사내 유틸리티 라이브러리의 특성상, 아래와 같은 구조가 필요했다.</p>\n<ul>\n<li>프로젝트 간 코드 중복 제거 (ex. date formatter, error handler, toast utils 등)</li>\n<li>빌드 후 개별 패키지로 publish, 각 프로젝트에서 scoped import로 사용</li>\n<li>사내 프라이빗 레지스트리로 퍼블리싱 (Verdaccio)</li>\n<li>자동화 배포 스크립트 (Lerna + Git tag 기반 publish)</li>\n</ul>\n<p>이를 고려했을 때 <code>Turborepo</code>, <code>Nx</code> 같은 최신 도구도 고려했지만,</p>\n<ul>\n<li>Nx는 workspace 내 모든 패키지가 동일한 버전 관리 체계를 요구하거나, monolithic CI 구조가 필요한 경우 더 적합하다고 생각</li>\n<li>Lerna는 더 유연한 버전 전략을 제공하고, 다양한 팀이 패키지를 독립적으로 운영할 수 있게 도와줌</li>\n<li>Verdaccio는 자체 인증과 스코프 제어를 통한 접근 제어가 가능</li>\n</ul>\n<p>그렇기에 Lerna + Verdaccio가 현재 상황에서 가장 합리적인 선택이었다.</p>\n<hr>\n<hr>\n<hr>\n<h2 id=\"lerna-기반-모노레포-아키텍처-구성\"><a class=\"anchor\" href=\"#lerna-기반-모노레포-아키텍처-구성\">Lerna 기반 모노레포 아키텍처 구성</a></h2>\n<p>사내 유틸리티 라이브러리는 장기적으로 확장 가능하고 모듈화된 구조여야 했다.</p>\n<p>단순히 공통 함수들을 모아두는 수준을 넘어서, 각기 다른 목적의 기능들이 하나의 레포 안에서 독립적으로 유지보수 가능해야 했기 때문이다.</p>\n<p>그래서 도입한 구조가 바로 <code>Lerna</code> 기반의 모노레포 아키텍처였다.</p>\n<hr>\n<h3 id=\"모노레포-패키지-구조-설계\"><a class=\"anchor\" href=\"#모노레포-패키지-구조-설계\">모노레포 패키지 구조 설계</a></h3>\n<p>모노레포에는 현재 두 개의 주요 패키지가 존재한다.</p>\n<ul>\n<li><code>@company/common-library</code>: 날짜 파싱, 타입 헬퍼, 유효성 검사 등 다양한 프론트엔드 프로젝트에서 재사용되는 범용 유틸리티 모듈</li>\n<li><code>@company/napi</code>: 내부 시스템과 연동되는 네이티브 API wrapper 혹은 RPC 클라이언트 역할의 모듈</li>\n</ul>\n<p>이런 구조를 통해 <strong>도메인 별 패키지 책임을 분리하면서도</strong>, 공통 코드베이스 안에서 통합 관리가 가능하도록 구성했다.</p>\n<pre><code>packages/\n├── company-common-library/\n├── company-napi/\n</code></pre>\n<p>패키지들은 모두 <code>packages/</code> 디렉토리 하위에 존재하며, 각각 독립적인 <code>package.json</code>, 빌드, 테스트 환경을 가진다.</p>\n<h3 id=\"lerna-설정-lernajson과-버전-관리\"><a class=\"anchor\" href=\"#lerna-설정-lernajson과-버전-관리\">Lerna 설정 (<code>lerna.json</code>)과 버전 관리</a></h3>\n<figure data-rehype-pretty-code-figure=\"\"><pre tabindex=\"0\" data-language=\"json\" data-theme=\"github-dark github-light\"><code data-language=\"json\" data-theme=\"github-dark github-light\" style=\"display: grid;\"><span data-line=\"\"><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">{</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#79B8FF;--shiki-light:#005CC5\">  \"version\"</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">: </span><span style=\"--shiki-dark:#9ECBFF;--shiki-light:#032F62\">\"independent\"</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">,</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#79B8FF;--shiki-light:#005CC5\">  \"packages\"</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">: [</span><span style=\"--shiki-dark:#9ECBFF;--shiki-light:#032F62\">\"packages/*\"</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">],</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#79B8FF;--shiki-light:#005CC5\">  \"npmClient\"</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">: </span><span style=\"--shiki-dark:#9ECBFF;--shiki-light:#032F62\">\"pnpm\"</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">}</span></span></code></pre></figure>\n<p>Lerna는 기본적으로 두 가지 버전 전략을 지원한다</p>\n<ul>\n<li><strong>fixed 모드</strong> : 모든 패키지가 같은 버전으로 관리됨</li>\n<li><strong>independent 모드</strong> : 패키지별로 독립적인 버전 관리</li>\n</ul>\n<p>우리는 <code>independent</code> 모드를 선택했는데, 이 전략에서는 다음과 같은 방식으로 버전이 관리된다.</p>\n<ul>\n<li><code>lerna publish</code> 실행 시, git 히스토리를 기준으로 각 패키지별 변경 여부를 분석</li>\n<li>변경이 감지된 패키지만 대상으로 <code>patch</code>, <code>minor</code>, <code>major</code> 중 하나로 버전 증가</li>\n<li>해당 패키지의 <code>package.json</code> 버전을 올리고, 태그를 각각 생성</li>\n<li>결과적으로 버전은 다음처럼 분기될 수 있다</li>\n</ul>\n<figure data-rehype-pretty-code-figure=\"\"><pre tabindex=\"0\" data-language=\"json\" data-theme=\"github-dark github-light\"><code data-language=\"json\" data-theme=\"github-dark github-light\" style=\"display: grid;\"><span data-line=\"\"><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">company-common-library@</span><span style=\"--shiki-dark:#79B8FF;--shiki-light:#005CC5\">1.0</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">.</span><span style=\"--shiki-dark:#79B8FF;--shiki-light:#005CC5\">0</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">company-napi@</span><span style=\"--shiki-dark:#79B8FF;--shiki-light:#005CC5\">1.0</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">.</span><span style=\"--shiki-dark:#79B8FF;--shiki-light:#005CC5\">0</span></span></code></pre></figure>\n<p>이렇게 하게 되면 변경되지 않은 패키지를 불필요하게 배포하지 않아도 되고, 공통 유틸리티와 도메인별 모듈 간 릴리즈 흐름 분리가 쉬우며, 팀 간 병렬적인 개발/배포가 가능하다.</p>\n<p><code>independent</code> 버전 전략에서는 각 패키지가 독립적으로 버전 업되기 때문에, <strong>패키지 간 참조 관계</strong>에 주의가 필요하다.</p>\n<p>예를 들어 <code>@company/common-library</code>를 사용하는 <code>@company/napi</code>가 있을 경우, common-library가 새로 릴리즈되더라도, napi가 참조하는 버전 범위에 해당하지 않으면 업데이트가 반영되지 않는다.</p>\n<p>이를 방지하기 위해서는 다음 두 가지를 고려해볼 수 있다.</p>\n<hr>\n<h4 id=\"version-range-설정---etc\"><a class=\"anchor\" href=\"#version-range-설정---etc\">Version Range 설정 (<code>^</code>, <code>~</code>, etc.)</a></h4>\n<p>보통 <code>^1.0.0</code>과 같이 major version 범위 내에서 자동 업데이트를 허용하는 방식이 사용된다.\n이는 common-library가 <code>1.0.0 → 1.2.3</code>으로 변경되어도 napi가 자동으로 최신 버전을 참조할 수 있게 한다.\n하지만 <code>1.0.0 → 2.0.0</code> 같은 breaking change는 자동으로 반영되지 않도록 막는다.</p>\n<hr>\n<h4 id=\"ci-테스트와-통합-빌드-검증\"><a class=\"anchor\" href=\"#ci-테스트와-통합-빌드-검증\">CI 테스트와 통합 빌드 검증</a></h4>\n<p>버전이 올라간 패키지가 다른 패키지에 영향을 주는 경우, 의존 패키지에서도 함께 테스트해야 한다.</p>\n<p>CI 파이프라인에서는 전체 workspace를 대상으로 테스트를 실행하거나, <strong>Lerna의 affected strategy (--since, --scope)를</strong> 활용해 영향받는 패키지만 테스트하는 것도 방법이다.</p>\n<p>여기서 Lerna의 affected strategy는 변경된 패키지에 대해서만 작업을 수행하기 위한 전략을 의미한다. <code>--since</code> 옵션을 통해 지정된 Git ref 이후 변경된 패키지에만 명령 적용할 수 있고, <code>--scope</code> 옵션을 통해 특정 패키지에만 명령을 적용할 수 있다.</p>\n<h3 id=\"pnpm-workspace와의-연동\"><a class=\"anchor\" href=\"#pnpm-workspace와의-연동\">pnpm workspace와의 연동</a></h3>\n<p><code>package.json</code> 루트에서는 <code>workspaces</code> 설정을 통해 pnpm과 Lerna의 패키지 인식 범위를 통일했다.</p>\n<figure data-rehype-pretty-code-figure=\"\"><pre tabindex=\"0\" data-language=\"json\" data-theme=\"github-dark github-light\"><code data-language=\"json\" data-theme=\"github-dark github-light\" style=\"display: grid;\"><span data-line=\"\"><span style=\"--shiki-dark:#9ECBFF;--shiki-light:#032F62\">\"workspaces\"</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">: [</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#9ECBFF;--shiki-light:#032F62\">  \"packages/*\"</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">]</span></span></code></pre></figure>\n<p>pnpm은 Lerna와 달리 의존성을 루트에 hoist하지 않고 <code>.pnpm</code> 디렉토리에 격리해 설치한다.<br>\n덕분에 패키지 간 충돌을 방지할 수 있다. 그리고 파일을 여러 위치에 <strong>복사</strong>하지 않고, 하나의 실제 파일을 여러 위치에서 <strong>참조</strong>하게 만드는 방식인 <strong>하드링크 기반 캐싱</strong>을 통해 빌드 속도까지 개선된다.</p>\n<p>또한 <code>root</code> 패키지를 <code>file:</code>로 의존성 선언해 내부 참조 관계를 명시적으로 설정하였다</p>\n<figure data-rehype-pretty-code-figure=\"\"><pre tabindex=\"0\" data-language=\"json\" data-theme=\"github-dark github-light\"><code data-language=\"json\" data-theme=\"github-dark github-light\" style=\"display: grid;\"><span data-line=\"\"><span style=\"--shiki-dark:#9ECBFF;--shiki-light:#032F62\">\"devDependencies\"</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">: {</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#79B8FF;--shiki-light:#005CC5\">  \"root\"</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">: </span><span style=\"--shiki-dark:#9ECBFF;--shiki-light:#032F62\">\"file:../../\"</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">}</span></span></code></pre></figure>\n<h3 id=\"패키지별-빌드-전략과-타입-관리\"><a class=\"anchor\" href=\"#패키지별-빌드-전략과-타입-관리\">패키지별 빌드 전략과 타입 관리</a></h3>\n<p>각 패키지는 vite + tsc 조합으로 빌드된다.</p>\n<p>공통 모듈은 vite로 번들링된 ESM을 export하고, 동시에 <code>dts-bundle-generator</code>를 사용해 모든 타입 정의를 하나의 .d.ts 파일로 정리한다.</p>\n<figure data-rehype-pretty-code-figure=\"\"><pre tabindex=\"0\" data-language=\"json\" data-theme=\"github-dark github-light\"><code data-language=\"json\" data-theme=\"github-dark github-light\" style=\"display: grid;\"><span data-line=\"\"><span style=\"--shiki-dark:#9ECBFF;--shiki-light:#032F62\">\"build\"</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">: </span><span style=\"--shiki-dark:#9ECBFF;--shiki-light:#032F62\">\"del-cli build/**/* &#x26;&#x26; tsc &#x26;&#x26; vite build &#x26;&#x26; dts-bundle-generator ...\"</span></span></code></pre></figure>\n<p>dts-bundle-generator 이란?</p>\n<ul>\n<li>TypeScript로 작성된 라이브러리를 외부에 제공할 때, 여러 개의 .d.ts 파일 대신 하나의 진입점 타입 파일을 생성해주는 도구</li>\n<li>내부적으로 모든 타입 의존성을 분석해 export 기준으로 병합</li>\n<li>타입만 사용하는 외부 라이브러리(zod, type-fest 등)는 inline 방식으로 포함 가능</li>\n<li>IDE에서 자동 완성, 타입 추론이 명확해지고, 사용자 입장에서도 import가 간결해지게 한다</li>\n</ul>\n<p><code>exports</code> 필드는 타입, 브라우저, 기본 엔트리를 명시적으로 구분해 다양한 런타임에서도 타입 추론이 정확히 동작하도록 구성했다</p>\n<figure data-rehype-pretty-code-figure=\"\"><pre tabindex=\"0\" data-language=\"json\" data-theme=\"github-dark github-light\"><code data-language=\"json\" data-theme=\"github-dark github-light\" style=\"display: grid;\"><span data-line=\"\"><span style=\"--shiki-dark:#9ECBFF;--shiki-light:#032F62\">\"exports\"</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">: {</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#79B8FF;--shiki-light:#005CC5\">  \".\"</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">: {</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#79B8FF;--shiki-light:#005CC5\">    \"types\"</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">: </span><span style=\"--shiki-dark:#9ECBFF;--shiki-light:#032F62\">\"./dist/company-common-library.d.ts\"</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">, </span><span style=\"--shiki-dark:#6A737D;--shiki-light:#6A737D\">// TypeScript에서 import 시 참조할 타입 선언 파일</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#79B8FF;--shiki-light:#005CC5\">    \"browser\"</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">: </span><span style=\"--shiki-dark:#9ECBFF;--shiki-light:#032F62\">\"./dist/company-common-library.js\"</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">, </span><span style=\"--shiki-dark:#6A737D;--shiki-light:#6A737D\">// 브라우저 번들 환경에서 우선적으로 참조할 모듈</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#79B8FF;--shiki-light:#005CC5\">    \"default\"</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">: </span><span style=\"--shiki-dark:#9ECBFF;--shiki-light:#032F62\">\"./dist/company-common-library.js\"</span><span style=\"--shiki-dark:#6A737D;--shiki-light:#6A737D\"> // 기타 환경(Node.js 등)에서 사용할 기본 모듈</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">  }</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">}</span></span></code></pre></figure>\n<p>Node.js 13 이상에서는 exports 필드를 통해 <strong>패키지 외부에서 import 가능한 경로를 명시적으로 제한</strong>할 수 있다. 이는 단순히 entry point를 설정하는 게 아니라, 내부 파일 구조를 외부에 노출하지 않도록 보호하는 기능이기도 하다.</p>\n<p>예를 들어 위 설정에서는 아래처럼만 import가 가능하고,</p>\n<figure data-rehype-pretty-code-figure=\"\"><pre tabindex=\"0\" data-language=\"ts\" data-theme=\"github-dark github-light\"><code data-language=\"ts\" data-theme=\"github-dark github-light\" style=\"display: grid;\"><span data-line=\"\"><span style=\"--shiki-dark:#F97583;--shiki-light:#D73A49\">import</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\"> { formatDate } </span><span style=\"--shiki-dark:#F97583;--shiki-light:#D73A49\">from</span><span style=\"--shiki-dark:#9ECBFF;--shiki-light:#032F62\"> '@company/common'</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">;</span></span></code></pre></figure>\n<p>직접 경로 접근은 불가능하다</p>\n<figure data-rehype-pretty-code-figure=\"\"><pre tabindex=\"0\" data-language=\"ts\" data-theme=\"github-dark github-light\"><code data-language=\"ts\" data-theme=\"github-dark github-light\" style=\"display: grid;\"><span data-line=\"\"><span style=\"--shiki-dark:#6A737D;--shiki-light:#6A737D\">// ❌ ERR_PACKAGE_PATH_NOT_EXPORTED 오류 발생</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#F97583;--shiki-light:#D73A49\">import</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\"> { formatDate } </span><span style=\"--shiki-dark:#F97583;--shiki-light:#D73A49\">from</span><span style=\"--shiki-dark:#9ECBFF;--shiki-light:#032F62\"> '@company/common/utils/format'</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">;</span></span></code></pre></figure>\n<h3 id=\"테스트와-커버리지-전략\"><a class=\"anchor\" href=\"#테스트와-커버리지-전략\">테스트와 커버리지 전략</a></h3>\n<p>유닛 테스트는 <code>vitest</code>로 작성되며, 공통 유틸 함수의 안정성과 리팩토링을 보장하기 위한 커버리지를 기본으로 포함했다.</p>\n<figure data-rehype-pretty-code-figure=\"\"><pre tabindex=\"0\" data-language=\"json\" data-theme=\"github-dark github-light\"><code data-language=\"json\" data-theme=\"github-dark github-light\" style=\"display: grid;\"><span data-line=\"\"><span style=\"--shiki-dark:#9ECBFF;--shiki-light:#032F62\">\"scripts\"</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">: {</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#79B8FF;--shiki-light:#005CC5\">  \"test\"</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">: </span><span style=\"--shiki-dark:#9ECBFF;--shiki-light:#032F62\">\"vitest\"</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">,</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#79B8FF;--shiki-light:#005CC5\">  \"test:coverage\"</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">: </span><span style=\"--shiki-dark:#9ECBFF;--shiki-light:#032F62\">\"vitest --coverage\"</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">}</span></span></code></pre></figure>\n<p><code>__tests__/</code>와 <code>__bench__/</code> 디렉토리는 기능 테스트 외에도 퍼포먼스 비교 테스트를 병행하도록 설계되었다.<br>\n이는 내부 util 함수들 간 병목 현상 탐지를 위한 구조이며, 런타임 성능 개선을 정량적으로 추적할 수 있게 한다.</p>\n<hr>\n<h2 id=\"verdaccio-기반-프라이빗-npm-레지스트리-구축\"><a class=\"anchor\" href=\"#verdaccio-기반-프라이빗-npm-레지스트리-구축\">Verdaccio 기반 프라이빗 NPM 레지스트리 구축</a></h2>\n<p>앞선 글에서 Lerna 기반의 모노레포 아키텍처를 통해 공통 유틸리티 라이브러리를 패키지 단위로 관리하는 구조를 살펴보았다.</p>\n<p>하지만 이를 실제로 배포하고 사용할 수 있으려면 내부 전용 NPM 레지스트리가 필요하다.</p>\n<h3 id=\"왜-내부-전용이어야-했을까\"><a class=\"anchor\" href=\"#왜-내부-전용이어야-했을까\">왜 내부 전용이어야 했을까?</a></h3>\n<p>우리가 관리하는 유틸리티 패키지에는 비즈니스 로직이 직접 담기지 않더라도, <strong>사내 시스템 구조나 네이밍, 유효성 규칙</strong> 등 외부에 노출되면 민감할 수 있는 내부 도메인 정보가 간접적으로 포함된다.</p>\n<p>또한, 사내 환경에 최적화된 설정 및 인터페이스를 포함하고 있기 때문에, 외부 레지스트리(NPM public registry)에서 공개적으로 운영하는 것이 적절하지 않다.</p>\n<p>무엇보다도 외부 패키지와의 <strong>네이밍 충돌이나 dependency confusion</strong> 같은 공격 벡터를 차단하기 위해, 스코프가 명확히 정의된 사설 레지스트리를 통해 관리하는 것이 더 안전하고 예측 가능하다.</p>\n<p>외부에 공개되지 않고, CI/CD와 연계되며, 접근 제어가 가능한 프라이빗 레지스트리를 구축하는 데 가장 적합한 도구는 바로 <strong>Verdaccio</strong>였다.</p>\n<p>Verdaccio는 경량화된 Node.js 기반 NPM registry로, 손쉽게 설치하고 구성할 수 있으며, Docker 환경과도 잘 통합된다.</p>\n<h3 id=\"docker-기반-레지스트리-인프라-구성\"><a class=\"anchor\" href=\"#docker-기반-레지스트리-인프라-구성\">Docker 기반 레지스트리 인프라 구성</a></h3>\n<p>사내 인프라에는 다음과 같은 형태로 <code>verdaccio</code> 인스턴스를 구성하였다:</p>\n<figure data-rehype-pretty-code-figure=\"\"><pre tabindex=\"0\" data-language=\"yaml\" data-theme=\"github-dark github-light\"><code data-language=\"yaml\" data-theme=\"github-dark github-light\" style=\"display: grid;\"><span data-line=\"\"><span style=\"--shiki-dark:#6A737D;--shiki-light:#6A737D\"># docker-compose.yml</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#85E89D;--shiki-light:#22863A\">version</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">: </span><span style=\"--shiki-dark:#9ECBFF;--shiki-light:#032F62\">'3.7'</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"--shiki-dark:#85E89D;--shiki-light:#22863A\">services</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">:</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#85E89D;--shiki-light:#22863A\">  verdaccio</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">:</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#85E89D;--shiki-light:#22863A\">    image</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">: </span><span style=\"--shiki-dark:#9ECBFF;--shiki-light:#032F62\">hub.docker.company.net/verdaccio</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#85E89D;--shiki-light:#22863A\">    container_name</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">: </span><span style=\"--shiki-dark:#9ECBFF;--shiki-light:#032F62\">verdaccio</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#85E89D;--shiki-light:#22863A\">    restart</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">: </span><span style=\"--shiki-dark:#9ECBFF;--shiki-light:#032F62\">always</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#85E89D;--shiki-light:#22863A\">    environment</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">:</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">      - </span><span style=\"--shiki-dark:#9ECBFF;--shiki-light:#032F62\">VERDACCIO_PORT=COMPANY_PORT</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#85E89D;--shiki-light:#22863A\">    ports</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">:</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">      - </span><span style=\"--shiki-dark:#9ECBFF;--shiki-light:#032F62\">COMPANY_PORT=PORT</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#85E89D;--shiki-light:#22863A\">    volumes</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">:</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">      - </span><span style=\"--shiki-dark:#9ECBFF;--shiki-light:#032F62\">storage:/verdaccio/storage</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#85E89D;--shiki-light:#22863A\">    networks</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">:</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">      - </span><span style=\"--shiki-dark:#9ECBFF;--shiki-light:#032F62\">verdaccio_bridge</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"--shiki-dark:#85E89D;--shiki-light:#22863A\">volumes</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">:</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#85E89D;--shiki-light:#22863A\">  storage</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">:</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"--shiki-dark:#85E89D;--shiki-light:#22863A\">networks</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">:</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#85E89D;--shiki-light:#22863A\">  verdaccio_bridge</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">:</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#85E89D;--shiki-light:#22863A\">    driver</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">: </span><span style=\"--shiki-dark:#9ECBFF;--shiki-light:#032F62\">bridge</span></span></code></pre></figure>\n<ul>\n<li><code>COMPANY_PORT</code>를 통해 외부 접근을 제공</li>\n<li><code>storage</code> 볼륨을 분리해 캐시 및 패키지 데이터를 지속성하게 저장</li>\n<li><code>verdaccio_bridge</code>를 통해 다른 사내 서비스와 연동 가능하도록 네트워크 분리</li>\n</ul>\n<h4 id=\"그럼-왜-별도의-네트워크verdaccio_bridge를-사용할까\"><a class=\"anchor\" href=\"#그럼-왜-별도의-네트워크verdaccio_bridge를-사용할까\">그럼 왜 별도의 네트워크(<code>verdaccio_bridge</code>)를 사용할까?</a></h4>\n<p>Docker Compose에서 <code>networks</code>를 명시적으로 분리한 이유는 <strong>사내 서비스 간 통신 경계를 제어하고 보안을 강화하기 위함</strong>이다.</p>\n<ul>\n<li><code>verdaccio</code>는 단일 독립 서비스가 아니라, CI/CD 서버, 릴리즈 빌더, 테스트 실행기 등 다양한 사내 컨테이너와 상호 작용하게 된다.</li>\n<li><code>verdaccio_bridge</code>라는 브릿지 네트워크에 연결된 서비스들만 <code>http://verdaccio:PORT</code> 형태로 내부 통신이 가능하다.</li>\n<li>외부에서의 접근은 오직 공개 포트(COMPANY_PORT)를 통해서만 가능하며, 내부 접근은 명시적으로 네트워크에 연결된 컨테이너로 제한된다.</li>\n</ul>\n<p>이 구조는 다음과 같은 효과를 제공한다</p>\n<p>| 목적 | 효과 |\n|------|------|\n| 내부 통신 제한 | 의도된 컨테이너 간 연결만 허용 (예: CI만 verdaccio에 접근 가능) |\n| 보안 강화 | 외부로부터 직접 접근을 막고, 네트워크 구간을 논리적으로 분리 |\n| 운영 유연성 | 환경별로 독립된 레지스트리 환경 구성 가능 (dev, staging, prod) |</p>\n<p>결국 Verdaccio가 포함된 도커 네트워크를 분리함으로써, 단순한 패키지 저장소 이상의 <strong>통제 가능한 사내 배포 허브</strong>로 기능하게 된다.</p>\n<hr>\n<h3 id=\"설정-파일-구조-및-접근-제어\"><a class=\"anchor\" href=\"#설정-파일-구조-및-접근-제어\">설정 파일 구조 및 접근 제어</a></h3>\n<p>핵심 설정은 <code>config.yaml</code>로 관리된다. 주요 설정 포인트는 다음과 같다</p>\n<figure data-rehype-pretty-code-figure=\"\"><pre tabindex=\"0\" data-language=\"yaml\" data-theme=\"github-dark github-light\"><code data-language=\"yaml\" data-theme=\"github-dark github-light\" style=\"display: grid;\"><span data-line=\"\"><span style=\"--shiki-dark:#85E89D;--shiki-light:#22863A\">storage</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">: </span><span style=\"--shiki-dark:#9ECBFF;--shiki-light:#032F62\">/verdaccio/storage</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#85E89D;--shiki-light:#22863A\">url_prefix</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">: </span><span style=\"--shiki-dark:#9ECBFF;--shiki-light:#032F62\">/npm/</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"--shiki-dark:#85E89D;--shiki-light:#22863A\">auth</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">:</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#85E89D;--shiki-light:#22863A\">  htpasswd</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">:</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#85E89D;--shiki-light:#22863A\">    file</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">: </span><span style=\"--shiki-dark:#9ECBFF;--shiki-light:#032F62\">/verdaccio/conf/htpasswd</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"--shiki-dark:#85E89D;--shiki-light:#22863A\">packages</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">:</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#9ECBFF;--shiki-light:#032F62\">  '@company/*'</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">:</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#85E89D;--shiki-light:#22863A\">    access</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">: </span><span style=\"--shiki-dark:#9ECBFF;--shiki-light:#032F62\">$authenticated</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#85E89D;--shiki-light:#22863A\">    publish</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">: </span><span style=\"--shiki-dark:#9ECBFF;--shiki-light:#032F62\">$authenticated</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"--shiki-dark:#9ECBFF;--shiki-light:#032F62\">  '**'</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">:</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#85E89D;--shiki-light:#22863A\">    access</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">: </span><span style=\"--shiki-dark:#9ECBFF;--shiki-light:#032F62\">$all</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#85E89D;--shiki-light:#22863A\">    publish</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">: </span><span style=\"--shiki-dark:#9ECBFF;--shiki-light:#032F62\">$authenticated</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#85E89D;--shiki-light:#22863A\">    proxy</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">: </span><span style=\"--shiki-dark:#9ECBFF;--shiki-light:#032F62\">npmjs</span></span></code></pre></figure>\n<h4 id=\"주요-포인트\"><a class=\"anchor\" href=\"#주요-포인트\">주요 포인트</a></h4>\n<ul>\n<li><code>@company/*</code> 스코프 패키지에 대해서는 인증된 사용자만 publish/read 가능하도록 설정</li>\n<li><code>proxy: npmjs</code> 설정으로, 사내 캐싱 기능과 fallback 지원</li>\n<li><code>url_prefix</code> 를 <code>/npm/</code>으로 설정해 nginx 리버스 프록시 또는 CI 내부에서 명확한 경로 관리 가능</li>\n<li>인증은 <code>htpasswd</code> 기반으로 구성하며, 사용자 수 제한 및 bcrypt 암호화도 설정 가능</li>\n</ul>\n<h4 id=\"인증htpasswd은-어떻게-동작할까\"><a class=\"anchor\" href=\"#인증htpasswd은-어떻게-동작할까\">인증(htpasswd)은 어떻게 동작할까?</a></h4>\n<p>auth.htpasswd 설정은 기본적인 HTTP 인증 기반으로 작동하며, htpasswd 파일은 <code>사용자명:해시된 패스워드</code> 형태로 저장된다.\n이때 사용되는 해시는 bcrypt이며, 패스워드 보안성과 저장 구조가 단순한 텍스트 인증보다 훌씬 안전하다.</p>\n<ul>\n<li>사용자 추가는 CLI 또는 직접 생성 가능</li>\n<li>publish, install 시 HTTP Authorization 헤더로 인증이 수행됨</li>\n<li>CI 환경에서는 npm login 또는 NPM_TOKEN으로 자동 처리 가능</li>\n<li>사용자 수가 많아질 경우 LDAP, OAuth 등의 외부 인증 연동 플러그인도 존재함</li>\n</ul>\n<h4 id=\"프록시proxy는-언제-동작하는가\"><a class=\"anchor\" href=\"#프록시proxy는-언제-동작하는가\">프록시(proxy)는 언제 동작하는가?</a></h4>\n<p>Verdaccio의 proxy 설정은 해당 패키지가 로컬(storage)에 존재하지 않을 때만 외부 registry로 요청을 전달한다.\n이 기능을 통해 사내에서 외부 패키지를 설치하더라도, 최초 요청 이후에는 로컬 캐시에 저장되므로 성능이 향상된다.</p>\n<ul>\n<li><code>proxy: npmjs</code>는 uplink로 https://registry.npmjs.org를 의미</li>\n<li>최초 요청 시 메타정보와 .tgz 파일이 /storage 디렉토리에 캐싱됨</li>\n<li>동일 요청은 외부 네트워크 없이 캐시에서 처리됨</li>\n</ul>\n<hr>\n<h3 id=\"보안을-고려한-운영-전략\"><a class=\"anchor\" href=\"#보안을-고려한-운영-전략\">보안을 고려한 운영 전략</a></h3>\n<p>프라이빗 레지스트리는 종종 <strong>dependency confusion</strong>과 같은 공격에 노출될 수 있다. 이를 방지하기 위해 다음과 같은 정책을 적용했다</p>\n<p>| 설정 항목 | 목적 |\n|----------|------|\n| <code>proxy</code> 제거 (특정 스코프에 대해) | 외부 npmjs로 fallback 막기 |\n| <code>publish</code> 제한 | 인증된 사용자만 업로드 가능 |\n| <code>unpublish</code> 제한 | 과거 버전 삭제 불가하도록 설정 |\n| <code>middlewares.audit.enabled: true</code> | 감사 로그 기록 활성화 |\n| Docker 내부 포트 비공개 | 외부 접근은 특정 게이트웨이에서만 허용 |</p>\n<p>@company/* 같이 사내 전용 스코프에는 프록시를 명시적으로 비활성화하는 것이 권장되고 있다.</p>\n<p>또한 Verdaccio와 proxy 조합에서는 스코프 전략과 외부 fallback 경로를 명확하게 구분하는 것이 중요하다.</p>\n<h3 id=\"퍼블리시-및-연동-흐름\"><a class=\"anchor\" href=\"#퍼블리시-및-연동-흐름\">퍼블리시 및 연동 흐름</a></h3>\n<p>패키지 publish는 다음과 같은 명령어 흐름으로 구성된다:</p>\n<figure data-rehype-pretty-code-figure=\"\"><pre tabindex=\"0\" data-language=\"bash\" data-theme=\"github-dark github-light\"><code data-language=\"bash\" data-theme=\"github-dark github-light\" style=\"display: grid;\"><span data-line=\"\"><span style=\"--shiki-dark:#B392F0;--shiki-light:#6F42C1\">pnpm</span><span style=\"--shiki-dark:#9ECBFF;--shiki-light:#032F62\"> build</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#B392F0;--shiki-light:#6F42C1\">npm</span><span style=\"--shiki-dark:#9ECBFF;--shiki-light:#032F62\"> set</span><span style=\"--shiki-dark:#9ECBFF;--shiki-light:#032F62\"> registry</span><span style=\"--shiki-dark:#9ECBFF;--shiki-light:#032F62\"> http://verdaccio.company.net:COMPANY_PORT/npm/</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#B392F0;--shiki-light:#6F42C1\">npm</span><span style=\"--shiki-dark:#9ECBFF;--shiki-light:#032F62\"> login</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#B392F0;--shiki-light:#6F42C1\">lerna</span><span style=\"--shiki-dark:#9ECBFF;--shiki-light:#032F62\"> publish</span><span style=\"--shiki-dark:#9ECBFF;--shiki-light:#032F62\"> patch</span><span style=\"--shiki-dark:#79B8FF;--shiki-light:#005CC5\"> --yes</span></span></code></pre></figure>\n<ul>\n<li><code>lerna publish</code>는 각 변경된 패키지에 대해 독립적으로 버전 증가 및 배포</li>\n<li><code>registry</code> 설정을 통해 verdaccio에 publish가 가능하도록 한다</li>\n<li>CI/CD에서는 <code>NPM_TOKEN</code>을 활용해 자동 로그인 처리</li>\n</ul>\n<hr>\n<p>Verdaccio를 통해 빠르고 간편하게 프라이빗 레지스트리를 구축할 수 있었다. 추가로 보안 설정과 proxy 전략을 적절히 조합하여, dependency confusion을 효과적으로 방지할 수 있었다.</p>\n<p>향후에는 OAuth 기반 인증, Web UI 비활성화, nginx 리버스 프록시 연동 등으로 보안 강화를 고민해봐도 좋을것 같다.</p>\n<hr>\n<h2 id=\"semantic-release-도입-배경\"><a class=\"anchor\" href=\"#semantic-release-도입-배경\">semantic-release 도입 배경</a></h2>\n<p>앞선 챕터에서는 <code>Lerna</code> 기반 모노레포와 <code>Verdaccio</code> 프라이빗 레지스트리 인프라 구성을 다루었다. 이제 이 구조가 실질적으로 작동하기 위해서는 <strong>버전 관리 및 배포 흐름의 자동화</strong>가 필요하다.</p>\n<p>특히 사내 라이브러리의 특성상 배포가 자주 발생하고, 사람이 직접 <code>lerna publish</code>에 버전 인자를 입력해 버전 번호를 관리하는 것은 실수의 여지가 크다. 또한 변경 없는 패키지까지 함께 publish 되는 경우 발생하기도 하고, 버전 증가 정책이 일관되지 않음으로써 버전 관리가 어려운 상황이 발생하기도한다.</p>\n<p>그래서 semantic-release(플러그인 기반의 릴리즈 파이프라인)를 활용해 커밋 메시지를 기반으로 자동으로 버전이 관리되도록 구성했다.</p>\n<p>semantic-release는 각 단계가 plugin으로 구성되며, release process의 각 역할(버전 계산, changelog 생성, git 태그, publish 등)을 분리된 모듈로 처리하는 특징을 가진다.</p>\n<p>기본 실행 흐름은 다음과 같다</p>\n<p><strong>commit-analyzer</strong> => <strong>release-notes-generator</strong> => <strong>npm</strong> => <strong>git</strong> =>  github, slack, etc… (Optional)</p>\n<hr>\n<h3 id=\"ci에서-semantic-release-자동-실행\"><a class=\"anchor\" href=\"#ci에서-semantic-release-자동-실행\">CI에서 semantic-release 자동 실행</a></h3>\n<p>semantic-release는 보통 GitHub Action 또는 GitLab CI와 함께 사용되지만, 우리는 사내 인프라를 위해 Bitbucket Pipelines를 기반으로 구성하였다.</p>\n<p>아래 예시와 같이 pipeline을 구성했다</p>\n<figure data-rehype-pretty-code-figure=\"\"><pre tabindex=\"0\" data-language=\"yaml\" data-theme=\"github-dark github-light\"><code data-language=\"yaml\" data-theme=\"github-dark github-light\" style=\"display: grid;\"><span data-line=\"\"><span style=\"--shiki-dark:#85E89D;--shiki-light:#22863A\">pipelines</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">:</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#85E89D;--shiki-light:#22863A\">  branches</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">:</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#85E89D;--shiki-light:#22863A\">    main</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">:</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">      - </span><span style=\"--shiki-dark:#85E89D;--shiki-light:#22863A\">step</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">:</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#85E89D;--shiki-light:#22863A\">          name</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">: </span><span style=\"--shiki-dark:#9ECBFF;--shiki-light:#032F62\">release</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#85E89D;--shiki-light:#22863A\">          caches</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">:</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">            - </span><span style=\"--shiki-dark:#9ECBFF;--shiki-light:#032F62\">node</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#85E89D;--shiki-light:#22863A\">          script</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">:</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">            - </span><span style=\"--shiki-dark:#9ECBFF;--shiki-light:#032F62\">pnpm install</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">            - </span><span style=\"--shiki-dark:#9ECBFF;--shiki-light:#032F62\">pnpm build</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">            - </span><span style=\"--shiki-dark:#9ECBFF;--shiki-light:#032F62\">pnpm semantic-release</span></span></code></pre></figure>\n<ul>\n<li>main 브랜치에 머지되면 자동으로 <code>semantic-release</code>가 실행되고</li>\n<li>커밋 메시지에 따라 버전이 증가하며, git tag가 생성되고</li>\n<li>지정된 레지스트리 (Verdaccio)로 패키지가 publish된다</li>\n</ul>\n<hr>\n<h3 id=\"lerna와의-통합\"><a class=\"anchor\" href=\"#lerna와의-통합\">Lerna와의 통합</a></h3>\n<p>Lerna 8 버전 이후에는 자체적인 conventional commits 기반 릴리즈 지원이 강화되었으나, 우리 구성에서는 <code>semantic-release</code> 단독 사용이 아닌, 다음과 같은 역할 분담 구조를 가졌다</p>\n<ul>\n<li>Lerna → 모노레포 패키지 실행 관리, build 스크립트 일괄 실행</li>\n<li>semantic-release → 버전 계산 및 git tag, changelog 생성</li>\n<li>pnpm → workspace 및 의존성 관리</li>\n</ul>\n<p>이 구조로 인해 각자의 역할이 명확하게 나뉘며, 중복 설정 없이 유지보수가 용이해졌다.</p>\n<hr>\n<p>semantic-release를 통해 다음과 같은 효과를 얻을 수 있었다</p>\n<ul>\n<li>사람이 직접 버전 관리를 하지 않아도 되어 실수 방지</li>\n<li>릴리즈 로그, git tag, changelog 자동 생성으로 배포 이력 관리 용이</li>\n<li>CI 환경에서 자동 publish 흐름 구성 → 완전한 GitOps 실현</li>\n</ul>\n<p>이는 특히 사내 공통 라이브러리처럼 빠르게 변화하고, 여러 프로젝트에서 재사용되는 컴포넌트를 관리할 때 큰 장점을 가진다.</p>\n<hr>\n<h2 id=\"scoped-패키지란\"><a class=\"anchor\" href=\"#scoped-패키지란\">Scoped 패키지란?</a></h2>\n<p>Scoped 패키지는 <code>@scope/name</code> 형태의 네이밍을 가진 NPM 패키지다.</p>\n<figure data-rehype-pretty-code-figure=\"\"><pre tabindex=\"0\" data-language=\"bash\" data-theme=\"github-dark github-light\"><code data-language=\"bash\" data-theme=\"github-dark github-light\" style=\"display: grid;\"><span data-line=\"\"><span style=\"--shiki-dark:#B392F0;--shiki-light:#6F42C1\">@company/company-common-library</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#B392F0;--shiki-light:#6F42C1\">@company/company-napi</span></span></code></pre></figure>\n<p>이를 통해 다음과 같은 효과를 얻을 수 있다:</p>\n<ul>\n<li><strong>패키지 네이밍의 네임스페이스화</strong> → 사내 도메인 명확화</li>\n<li><strong>프라이빗 레지스트리 내 권한 제어</strong> (config.yaml에서 <code>@company/*</code> 스코프 제한)</li>\n<li><strong>모듈 간 관계 파악 용이</strong> → 범용 vs 도메인 특화 모듈 구분</li>\n</ul>\n<p>Verdaccio의 설정에서도 <code>@company/*</code> 에 대해 별도의 접근 및 publish 정책을 구성할 수 있어 보안/정책 관리에 적합하다.</p>\n<hr>\n<h3 id=\"서비스-프로젝트에서-설치-및-사용\"><a class=\"anchor\" href=\"#서비스-프로젝트에서-설치-및-사용\">서비스 프로젝트에서 설치 및 사용</a></h3>\n<p>패키지를 사용하려는 서비스 프로젝트에서는 다음과 같이 설정한다</p>\n<h4 id=\"npmrc-구성\"><a class=\"anchor\" href=\"#npmrc-구성\"><code>.npmrc</code> 구성</a></h4>\n<figure data-rehype-pretty-code-figure=\"\"><pre tabindex=\"0\" data-language=\"bash\" data-theme=\"github-dark github-light\"><code data-language=\"bash\" data-theme=\"github-dark github-light\" style=\"display: grid;\"><span data-line=\"\"><span style=\"--shiki-dark:#B392F0;--shiki-light:#6F42C1\">@company:registry</span><span style=\"--shiki-dark:#9ECBFF;--shiki-light:#032F62\">=http://verdaccio.company.net:COMPANY_PORT/npm/</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#B392F0;--shiki-light:#6F42C1\">//verdaccio.company.net:COMPANY_PORT/npm/:_authToken</span><span style=\"--shiki-dark:#9ECBFF;--shiki-light:#032F62\">=xxxxx</span></span></code></pre></figure>\n<ul>\n<li>특정 스코프(<code>@company</code>)만 내부 레지스트리로 리다이렉트</li>\n<li>나머지는 public npm registry를 그대로 사용</li>\n</ul>\n<p>이를 통해 내부 패키지는 Verdaccio에서, 외부 라이브러리는 기존 npm에서 가져오도록 이원화된 설정이 가능하다.</p>\n<h4 id=\"설치\"><a class=\"anchor\" href=\"#설치\">설치</a></h4>\n<p>라이브러리는 비공개이기떄문에, 설치 예시만 보여주겠다.</p>\n<figure data-rehype-pretty-code-figure=\"\"><pre tabindex=\"0\" data-language=\"bash\" data-theme=\"github-dark github-light\"><code data-language=\"bash\" data-theme=\"github-dark github-light\" style=\"display: grid;\"><span data-line=\"\"><span style=\"--shiki-dark:#B392F0;--shiki-light:#6F42C1\">pnpm</span><span style=\"--shiki-dark:#9ECBFF;--shiki-light:#032F62\"> install</span><span style=\"--shiki-dark:#9ECBFF;--shiki-light:#032F62\"> @company/company-common-library</span></span></code></pre></figure>\n<hr>\n<h3 id=\"import-방식\"><a class=\"anchor\" href=\"#import-방식\">import 방식</a></h3>\n<p>scoped 패키지로 배포된 유틸리티는 다음과 같이 프로젝트 내에서 import 가능하다:</p>\n<figure data-rehype-pretty-code-figure=\"\"><pre tabindex=\"0\" data-language=\"ts\" data-theme=\"github-dark github-light\"><code data-language=\"ts\" data-theme=\"github-dark github-light\" style=\"display: grid;\"><span data-line=\"\"><span style=\"--shiki-dark:#F97583;--shiki-light:#D73A49\">import</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\"> { formatDate, safeParse } </span><span style=\"--shiki-dark:#F97583;--shiki-light:#D73A49\">from</span><span style=\"--shiki-dark:#9ECBFF;--shiki-light:#032F62\"> '@company/company-common-library/utils/date'</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">;</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#F97583;--shiki-light:#D73A49\">import</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\"> { buildQueryString } </span><span style=\"--shiki-dark:#F97583;--shiki-light:#D73A49\">from</span><span style=\"--shiki-dark:#9ECBFF;--shiki-light:#032F62\"> '@company/company-common-library/utils/url'</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">;</span></span></code></pre></figure>\n<ul>\n<li>경량 ESM 번들로 export되기 때문에 트리 쉐이킹에 최적화</li>\n<li>타입 정의도 함께 제공되므로 TS 프로젝트에서 타입 추론이 즉시 가능</li>\n<li>IDE 자동완성 및 문서화에서 큰 이점</li>\n</ul>\n<hr>\n<h3 id=\"호환성과-배포-주기-전략\"><a class=\"anchor\" href=\"#호환성과-배포-주기-전략\">호환성과 배포 주기 전략</a></h3>\n<p>공통 유틸리티의 경우 <strong>주기적인 배포보다는 필요 기반의 배포 전략</strong>을 채택했다.<br>\nsemantic-release가 자동으로 버전을 관리해주기 때문에, 사용처에서는 아래 전략을 따라간다</p>\n<ul>\n<li>patch 업데이트는 바로 반영</li>\n<li>minor 이상 업데이트는 PR에 release note 링크 포함 후 수동 반영</li>\n<li>major 업데이트는 코드베이스 검토 및 팀 공유 후 채택</li>\n</ul>\n<p>또한 scoped 패키지는 <strong>사내 Monorepo가 아닌 외부 레포</strong>에서도 문제 없이 사용할 수 있다는 점이 큰 장점이다.</p>\n<hr>\n<h2 id=\"결론\"><a class=\"anchor\" href=\"#결론\">결론</a></h2>\n<p>이번 유틸리티 라이브러리 구축 프로젝트는 단순히 패키지를 나누고 배포하는 수준을 넘어, 사내 개발 생산성, 코드 품질, 협업 효율성을 구조적으로 끌어올리기 위한 인프라 작업이었다.</p>\n<hr>\n<p><img src=\"/content/250404/2.png\" alt=\"2.png\" loading=\"lazy\" decoding=\"async\"></p>\n<hr>\n<p>✅ 도입을 통해 얻게 된 주요 장점</p>\n<ul>\n<li>semantic-release를 통해 사람이 직접 버전 숫자를 관리하지 않아도 됨</li>\n<li>Lerna + pnpm을 통해 패키지를 독립적으로 유지보수 가능</li>\n<li>Verdaccio + scoped registry를 통해 외부 노출 없이 안전하게 운영</li>\n<li>단일 install로 사용 가능하며 타입 정의 및 import 구조까지 통일</li>\n<li>publish → install → 반영까지 모든 흐름이 자동화되어 안정적</li>\n</ul>\n<p>가장 큰 장점은 <strong>유지보수가 쉬운 아키텍처가 되었다</strong>는 점이다.</p>\n<p>사람에 의존한 규칙이 아니라, 구조와 도구 자체가 품질과 일관성을 유지해주기 때문이다.</p>\n<p><strong>이러한 인프라가 갖춰졌을 때, 개발자는 더 이상 공통 로직을 복사하거나 컨벤션을 따로 전달하지 않아도 된다. 이제는 그냥 install 하면 되고, 자동으로 type도 따라온다.</strong></p>\n<hr>\n<h2 id=\"앞으로의-개선-포인트\"><a class=\"anchor\" href=\"#앞으로의-개선-포인트\">앞으로의 개선 포인트</a></h2>\n<ul>\n<li>\n<p>전환 고려 여러 패키지에 영향을 주는 경우에는 Changesets의 PR 단위 버전 제안이 더 유리할 수도 있다고 생각해, semantic-release → Changesets 전환도 고려해볼 것 같다.</p>\n</li>\n<li>\n<p>Verdaccio 인증 방식 개선 : 현재는 htpasswd 기반이지만, 사내 SSO 또는 OAuth2 연동 등 중앙 인증과 통합 가능성 검토..</p>\n</li>\n<li>\n<p>컴포넌트 단위 모듈 분리 : 현재는 유틸리티 중심이지만, 디자인 시스템이나 React 컴포넌트도 동일한 방식으로 확장 가능</p>\n</li>\n<li>\n<p>릴리즈 노트 시각화 자동화 : Slack 연동 및 Github Actions 기반 release summary 자동 게시 등 운영 효율화를 추가 검토 중.. (공수가 너무 크다)</p>\n</li>\n</ul>\n<hr>\n<p>인프라는 결국 <strong>개발 문화와 협업 체계의 중심</strong>을 구성하는 것이다.</p>\n<p>처음엔 번거롭고 복잡해 보이지만, 한 번 체계를 만들어두면 이후의 유지 비용은 급격히 줄어든다.</p>\n<p>힘든 일 뒤에 보람이 온다고 했던가. 지금 와서 돌아보면, 꽤 괜찮은 경험이었다.</p>\n<hr>\n<p><img src=\"/content/250404/1.jpg\" alt=\"1.jpg\" loading=\"lazy\" decoding=\"async\"></p>\n<hr>\n<figure data-rehype-pretty-code-figure=\"\"><pre tabindex=\"0\" data-language=\"toc\" data-theme=\"github-dark github-light\"><code data-language=\"toc\" data-theme=\"github-dark github-light\" style=\"display: grid;\"><span data-line=\"\"> </span></code></pre></figure>"
  },
  "_id": "250404/index.md",
  "_raw": {
    "sourceFilePath": "250404/index.md",
    "sourceFileName": "index.md",
    "sourceFileDir": "250404",
    "contentType": "markdown",
    "flattenedPath": "250404"
  },
  "type": "Post",
  "slug": "/250404",
  "categoryArray": [
    "프론트엔드",
    "인프라"
  ],
  "readingTime": "32 min read",
  "excerpt": "회사 내에서 프론트엔드 공통 유틸리티 모듈을 통합 관리하는 작업을 맡으면서, 다음과 같은 요구사항이 생겼다. 여러 레포지토리에 중복된 로직을 하나로 추출해 관리하고 싶다. 패키지 단위로 분리해 모노레포 형태로 운영하되, 유연한 버전 관리가 필요하다. 외부 공개 없이 사내에서만 배포 및 사용 가능한 NPM 패키지 레지스트리를 갖추고 싶다. CI/CD 파이프라..."
}