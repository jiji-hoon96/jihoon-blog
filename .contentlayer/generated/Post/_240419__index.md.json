{
  "title": "useEffect의 Dependency로 useRef를 사용해보자!",
  "date": "2024-04-19T00:00:00.000Z",
  "categories": "소박한궁금증 React",
  "body": {
    "raw": "\n<br>\n\n갑자기 작업하다가 궁금해져서 적는 첫번째 오이소박한 궁금증!!\n\n![1.jpeg](1.jpeg)\n\n<br>\n\n## useEffect의 dependency에 useRef를 넣으면?\n\nuseEffect 의 []에 의존성(dependency)를 넣을 수 있다! ~~이건 다 알고 있겠죠!?~~\n\n그러면 리렌더링이 될 때 어느 시점에 의존성이 작동 될 까!?\n\n긴말 말고 예시코드를 보자!\n\n![2.png](2.png)\n\n<br>\n\n위 코드는 useRef의 current, useState의 state를 handleButtonClick 함수를 이용해서 1씩 올려주는 코드다.\n\nuseEffect의 dependency에 useRef의 ref와 ref.current 의 값을 넣어보고 동작을 비교해보자~!!\n\n<br>\n\n### [ref]\n\n<br>\n\n```typescript\nuseEffect(() => {\n  conosle.log('Ref의 값:', ref);\n}, [ref]);\n```\n\n<br>\n\n<video width=\"700\" height=\"500\" controls>\n  <source src=\"3.mov\" type=\"video/mp4\">\n</video>\n\n<br>\n\nuseRef의 ref 객체를 dependency에 직접 넣어주게 되면 useEffect가 변경사항을 감지하지 못하고 리렌더링 되지 않는다.. 하지만 값은 변경된다!!!\n\n<br>\n\n### [ref.current]\n\n<br>\n\n```typescript\nuseEffect(() => {\n  conosle.log('Ref의 값:', ref);\n}, [ref.current]);\n```\n\n<br>\n\n<video width=\"700\" height=\"500\" controls >\n  <source src=\"4.mov\" type=\"video/mp4\">\n</video>\n\n<br>\n\n그리고 useRef의 ref.current 값 을 dependency에 직접 넣어주게 되면 useEffect가 변경사항을 감지하고 리렌더링을 하게된다.\n\n<br>\n\n## 왜 이럴까??\n\n![5.jpeg](5.jpeg)\n\nuseEffect의 의존성 배열에 ref를 직접 넣으면 리렌더링이 발생하지 않는 이유는 useEffect의 의존성 배열은 값의 변경 여부를 기준으로 한다.\n\n> ⚠️⚠️ useEffect dependency\n>\n> 값들의 변경 여부를 판단할 때 얕은 비교(shallow comparison)가 이루어지기 때문에 배열 내부의 값들이 단순한 원시값(숫자, 문자열 등)이거나 참조 타입의 경우에는 그 참조가 동일한지를 확인한다.\n>\n> 만약 배열 내부의 객체나 배열과 같은 참조 타입의 값이 변경되었다고 해도, 배열 내의 객체나 배열의 참조 자체가 변경되지 않으면 useEffect는 다시 실행되지 않는다.\n\nref 변수 자체는 컴포넌트 내부에서 변경되는 것이 아니라, 그 안에 있는 current 속성이 변경될 때만 의존성이 작동해야 한다. 그러나 ref 변수의 참조 자체는 항상 동일하므로 의존성 배열에 ref를 직접 넣는다고 해서 useEffect가 리렌더링을 유도하지 않는다.\n\n반면에 ref.current를 의존성 배열에 넣으면 useEffect는 ref.current 값이 변경될 때마다 다시 실행된다. ref.current 값은 직접 변경되는 값이므로 이를 의존성으로 사용하면 useEffect는 해당 값의 변경을 감지하여 다시 실행되고, 리렌더링이 발생한다.\n\n이를 통해 useEffect의 의존성 배열에는 값의 변경을 감지할 수 있는 항목을 포함해야 하며, ref 변수의 경우에는 주로 ref.current와 같은 값을 사용하여 의존성을 설정하는 것이 적절하다.\n\n<br>\n\n<strong>한줄요약 : ref 변수의 참조 자체가 변경되는 것이 아니라 current 속성이 변경될 때만 의존성이 작동 </strong>\n\n```toc\n\n```\n",
    "html": "<p>갑자기 작업하다가 궁금해져서 적는 첫번째 오이소박한 궁금증!!</p>\n<p><img src=\"/content/240419/1.jpeg\" alt=\"1.jpeg\"></p>\n<h2 id=\"useeffect의-dependency에-useref를-넣으면\"><a class=\"anchor\" href=\"#useeffect의-dependency에-useref를-넣으면\">useEffect의 dependency에 useRef를 넣으면?</a></h2>\n<p>useEffect 의 []에 의존성(dependency)를 넣을 수 있다! ~~이건 다 알고 있겠죠!?~~</p>\n<p>그러면 리렌더링이 될 때 어느 시점에 의존성이 작동 될 까!?</p>\n<p>긴말 말고 예시코드를 보자!</p>\n<p><img src=\"/content/240419/2.png\" alt=\"2.png\"></p>\n<p>위 코드는 useRef의 current, useState의 state를 handleButtonClick 함수를 이용해서 1씩 올려주는 코드다.</p>\n<p>useEffect의 dependency에 useRef의 ref와 ref.current 의 값을 넣어보고 동작을 비교해보자~!!</p>\n<h3 id=\"ref\"><a class=\"anchor\" href=\"#ref\">[ref]</a></h3>\n<figure data-rehype-pretty-code-figure=\"\"><pre tabindex=\"0\" data-language=\"typescript\" data-theme=\"github-dark github-light\"><code data-language=\"typescript\" data-theme=\"github-dark github-light\" style=\"display: grid;\"><span data-line=\"\"><span style=\"--shiki-dark:#B392F0;--shiki-light:#6F42C1\">useEffect</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">(() </span><span style=\"--shiki-dark:#F97583;--shiki-light:#D73A49\">=></span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\"> {</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">  conosle.</span><span style=\"--shiki-dark:#B392F0;--shiki-light:#6F42C1\">log</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">(</span><span style=\"--shiki-dark:#9ECBFF;--shiki-light:#032F62\">'Ref의 값:'</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">, ref);</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">}, [ref]);</span></span></code></pre></figure>\n<p>useRef의 ref 객체를 dependency에 직접 넣어주게 되면 useEffect가 변경사항을 감지하지 못하고 리렌더링 되지 않는다.. 하지만 값은 변경된다!!!</p>\n<h3 id=\"refcurrent\"><a class=\"anchor\" href=\"#refcurrent\">[ref.current]</a></h3>\n<figure data-rehype-pretty-code-figure=\"\"><pre tabindex=\"0\" data-language=\"typescript\" data-theme=\"github-dark github-light\"><code data-language=\"typescript\" data-theme=\"github-dark github-light\" style=\"display: grid;\"><span data-line=\"\"><span style=\"--shiki-dark:#B392F0;--shiki-light:#6F42C1\">useEffect</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">(() </span><span style=\"--shiki-dark:#F97583;--shiki-light:#D73A49\">=></span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\"> {</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">  conosle.</span><span style=\"--shiki-dark:#B392F0;--shiki-light:#6F42C1\">log</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">(</span><span style=\"--shiki-dark:#9ECBFF;--shiki-light:#032F62\">'Ref의 값:'</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">, ref);</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">}, [ref.current]);</span></span></code></pre></figure>\n<p>그리고 useRef의 ref.current 값 을 dependency에 직접 넣어주게 되면 useEffect가 변경사항을 감지하고 리렌더링을 하게된다.</p>\n<h2 id=\"왜-이럴까\"><a class=\"anchor\" href=\"#왜-이럴까\">왜 이럴까??</a></h2>\n<p><img src=\"/content/240419/5.jpeg\" alt=\"5.jpeg\"></p>\n<p>useEffect의 의존성 배열에 ref를 직접 넣으면 리렌더링이 발생하지 않는 이유는 useEffect의 의존성 배열은 값의 변경 여부를 기준으로 한다.</p>\n<blockquote>\n<p>⚠️⚠️ useEffect dependency</p>\n<p>값들의 변경 여부를 판단할 때 얕은 비교(shallow comparison)가 이루어지기 때문에 배열 내부의 값들이 단순한 원시값(숫자, 문자열 등)이거나 참조 타입의 경우에는 그 참조가 동일한지를 확인한다.</p>\n<p>만약 배열 내부의 객체나 배열과 같은 참조 타입의 값이 변경되었다고 해도, 배열 내의 객체나 배열의 참조 자체가 변경되지 않으면 useEffect는 다시 실행되지 않는다.</p>\n</blockquote>\n<p>ref 변수 자체는 컴포넌트 내부에서 변경되는 것이 아니라, 그 안에 있는 current 속성이 변경될 때만 의존성이 작동해야 한다. 그러나 ref 변수의 참조 자체는 항상 동일하므로 의존성 배열에 ref를 직접 넣는다고 해서 useEffect가 리렌더링을 유도하지 않는다.</p>\n<p>반면에 ref.current를 의존성 배열에 넣으면 useEffect는 ref.current 값이 변경될 때마다 다시 실행된다. ref.current 값은 직접 변경되는 값이므로 이를 의존성으로 사용하면 useEffect는 해당 값의 변경을 감지하여 다시 실행되고, 리렌더링이 발생한다.</p>\n<p>이를 통해 useEffect의 의존성 배열에는 값의 변경을 감지할 수 있는 항목을 포함해야 하며, ref 변수의 경우에는 주로 ref.current와 같은 값을 사용하여 의존성을 설정하는 것이 적절하다.</p>\n<p>한줄요약 : ref 변수의 참조 자체가 변경되는 것이 아니라 current 속성이 변경될 때만 의존성이 작동 </p>\n<figure data-rehype-pretty-code-figure=\"\"><pre tabindex=\"0\" data-language=\"toc\" data-theme=\"github-dark github-light\"><code data-language=\"toc\" data-theme=\"github-dark github-light\" style=\"display: grid;\"><span data-line=\"\"> </span></code></pre></figure>"
  },
  "_id": "240419/index.md",
  "_raw": {
    "sourceFilePath": "240419/index.md",
    "sourceFileName": "index.md",
    "sourceFileDir": "240419",
    "contentType": "markdown",
    "flattenedPath": "240419"
  },
  "type": "Post",
  "slug": "/240419",
  "categoryArray": [
    "소박한궁금증",
    "React"
  ],
  "readingTime": "4 min read",
  "excerpt": "갑자기 작업하다가 궁금해져서 적는 첫번째 오이소박한 궁금증!! useEffect의 dependency에 useRef를 넣으면? useEffect 의 []에 의존성(dependency)를 넣을 수 있다! 이건 다 알고 있겠죠!? 그러면 리렌더링이 될 때 어느 시점에 의존성이 작동 될 까!? 긴말 말고 예시코드를 보자! 위 코드는 useRef의 current,..."
}