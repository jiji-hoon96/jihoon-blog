{
  "title": "What is useState?",
  "date": "2023-08-20T00:00:00.000Z",
  "categories": "프론트엔드 React",
  "body": {
    "raw": "\n함수형 컴포넌트는 **렌더링**이 일어날 때마다 컴포넌트 함수가 다시 호출됩니다. 그래서 함수 내부의 일반변수는 호출이 끝나면 사라지고, 다음 렌더에서 처음부터 다시 만들어집니다. 그렇기에 **렌더 사이에 유지되어야 하는 값**을 일반 변수로 들고 있으면 값이 유지되지 않습니다.\n\n반대로 `useState`는 값이 컴포넌트 함수 안에 저장되는 게 아니라, React가 렌더 사이에 따로 보관하고 있다가, 해당 렌더 시점에 스냅샷처럼 꺼내서 컴포넌트에 제공합니다. 그래서 상태값은 **변수처럼 바로 바뀌는 것**이 아니라, `setState`를 호출하면 다음 렌더를 예약하고, 다음 렌더에서 바뀐 상태 스냅샷을 받게 됩니다.\n\n여기서 중요한 점은, props도 마찬가지로 **그 렌더의 입력값**입니다. 함수형 컴포넌트의 관점에서 props는 읽기 전용 입력이고, 컴포넌트는 props와 state로 UI를 계산해 내는 구조입니다. 상태를 바꾸고 싶다면 props를 건드리는 게 아니라 `setState`를 활용해 다음 렌더의 상태를 바꾸는 방식으로 접근해야 합니다.\n\n```jsx\nfunction Counter() {\n  let local = 0;\n  const [count, setCount] = useState(0);\n\n  const onClick = () => {\n    local += 1;\n    setCount(count + 1);\n    console.log(local, count);\n  };\n\n  return <button onClick={onClick}>{count}</button>;\n}\n```\n\n여기서 `local` 변수는 렌더 사이에 유지되지 않기 때문에, 클릭할 때마다 `0`으로 초기화됩니다. 하지만 `count`는 `useState`를 통해 렌더 사이에 유지되므로, 클릭할 때마다 증가합니다. 하지만 `count`는 클릭하게되면 `setCount`가 현재 실행 중인 코드의 변수를 바꾸는게 아니라 다음 렌더를 트리거하기 때문에 클릭 즉시 바뀌지 않습니다.\n\n이 글에서 useState에 대해서 공식문서를 기준으로 값들이 어떻게 유지되고, 이어지는지에 대해서 이야기해보려합니다.\n\n## useState 란 무엇인가\n\n`useState`는 **함수형 컴포넌트에 상태(state)를 추가**하기 위한 Hook입니다. React는 상태를 컴포넌트 함수 내부 변수로 두는 게 아니라 **렌더 사이에 별도로 보관**해두고, 각 렌더마다 그 시점의 상태 **스냅샷**을 컴포넌트에 제공합니다. 그래서 상태를 바꾸는 행위는 **현재 변수 값을 즉시 바꾸는 것**이 아니라, **다음 렌더에서 사용할 상태를 예약**하는 방식으로 동작합니다.\n\n`useState`는 길이가 2개인 배열을 반환합니다. `state`는 현재 렌더에서의 상태 값(첫 렌더에서는 `initialState`), `setState`는 상태를 업데이트하고 리렌더를 트리거하는 함수입니다.\n\n```jsx\nconst [state, setState] = useState(initialState);\n```\n\n`initialState`는 `useState`가 처음 렌더링 될 때 반환하는 `state`의 초기값입니다. 초기 렌더 이후에는 무시됩니다. 그리고 `initialState`로 함수를 넘기면 그 함수는 **initializer function**으로 취급되어, React가 **초기화 시점에 호출한 반환값을 초기 상태로 저장**합니다. 이 방식은 초기값 계산이 비싼 경우에 유용합니다.\n\n아래 코드가 어떤 차이점을 보이는지 살펴보겠습니다.\n\n```jsx\nuseState(createInitialTodos());\nuseState(createInitialTodos);\n```\n\n두 함수 `initialState`의 차이점은 언제 호출되어 초기값이 설정되는지에 있습니다.\n\n첫 번째 코드는 매 렌더마다 `createInitialTodos()`가 호출되어 초기값이 설정됩니다. 하지만 두 번째 코드는 초기화 시점에만 `createInitialTodos`를 호출하여 초기값을 만듭니다. (Lazy Initialization)\n\n:::details\nLazy Initialization\n\nLazy Initialization 은 **useState의 초기값으로 값 대신 함수를 전달하여, 초기 로직이 첫 렌더링 시에만 실행되도록 하는 최적화 기법입니다.**\n\n`useState(heavyCalculation())`은 렌더링 될 때마다 heavyCalculation이 호출되어 낭비됩니다. 그래서 `useState(() => heavyCalculation())`로 최초 마운트 시에만 함수가 실행되고, 이후 리렌더링 때는 실행되지 않고 무시됩니다.\n:::\n\n`setState`는 **현재 실행 중인 코드의 state 변수를 즉시 바꾸지 않습니다.** 따라서 `setState` 직후에 `state`를 읽으면 이전 렌더의 값이 그대로 나올 수 있습니다.\n\n또한 `nextState`로 함수를 넘기면 React는 그 함수를 Queue에 쌓아두고, 다음 렌더에서 쌓인 업데이터들을 순서대로 적용해 최종 상태를 계산합니다.\n\n그렇게되면 setState가 여러번 호출되어도 실제로는 한 번만 렌더링되는데, 이것을 성능 향상을 위해 여러 개의 상태 업데이트(setState)를 하나의 그룹으로 묶어서 한 번만 렌더링하는 React의 처리 방식인 **배칭(batch)** 이라고 합니다.\n\n> [React 18](https://react.dev/blog/2022/03/29/react-v18)부터는 기본적으로 배칭 범위가 더 넓어져서, React 이벤트 핸들러뿐 아니라 setTimeout, Promise 등에서도 자동 배칭이 적용될 수 있습니다\n\n새로 넣은 값이 현재 state와 동일한지 `Object.is`로 비교하고 판단되면, React는 리렌더를 스킵할 수 있습니다.\n\n여기서 중요한 포인트는 **원시값(number,string,boolean)은 값 자체 비교**라는 것 입니다, 하지만 **객체/배열은 값이 아니라 참조(reference)가 같아야 동일한 값**으로 취급됩니다. 객체를 직접 수정(mutation)하면 참조가 유지되기 때문에 바뀐 것처럼 보이는데 리렌더가 안되거나/반대로 상태 불변성이 깨져 디버깅이 어려워지는 문제가 발생합니다.\n\n## 내부 동작\n\nReact를 사용하면 가장 쉽게 접하는 Hook 중 하나인 `useState`의 내부 코드를 살펴보면 수많은 자바스크립트 로직이 서로 얽혀져 있는 모습을 볼 수 있습니다. 내부 코드를 통해 `useState`가 상태를 어떻게 관리하고 있는지 살펴봅시다.\n\n`useState`를 이해하기 위해서는 **클로저(Closure)를** 이해해야 합니다.\n\n함수형 컴포넌트는 렌더링될 때마다 다시 호출됩니다. 그럼에도 부구하고 이전 상태값을 기억하는 이유는 무엇일까요? 아래 자바스크립트로 `useState`를 구현한 코드를 살펴보겠습니다.\n\n```jsx\nfunction useState(initialValue) {\n  var _val = initialValue; // 1. _val은 지역 변수이지만 클로저에 의해 캡처됨\n\n  function state() {\n    // state는 내부 함수이자 클로저\n    return _val; // 부모 함수의 _val을 참조\n  }\n\n  function setState(newVal) {\n    // _val 값을 직접 수정 (이 변수는 외부에서 접근 불가)\n    _val = newVal;\n  }\n\n  return [state, setState]; // 외부로 함수 노출\n}\n\nvar [foo, setFoo] = useState(0);\nconsole.log(foo()); // 0\nsetFoo(1);\nconsole.log(foo()); // 1\n```\n\n`useState`는 함수가 호출되고 종료되어도, 반환된 state, setState 함수는 **자신이 생성될 당시의 스코프(Lexical Environment)를 기억**합니다. 따라서 `_val`이라는 변수는 메모리 어딘가에 살아남아 값을 유지하게 됩니다.\n\n### ReactHooks.js\n\n실제 React에서는 수많은 컴포넌트의 수많은 Hook들을 순서대로 관리해야하기에 내부 구조가 많이 복잡합니다. 그래서 [모든 내부 구조](https://github.com/facebook/react/blob/main/packages/react/src/ReactHooks.js)를 살펴보는 것 보다는 필요한 부분만 살펴보도록 하겠습니다.\n\nReact는 컴포넌트가 **처음 렌더링될 때(Mount)와 업데이트 될 때(Update) 서로 다른 Dispatcher를 사용**합니다.\n\n아래 코드는 컴포넌트가 처음 마운트될 때 실행되는 `useState`의 진입점입니다\n\n```jsx\nuseState: function (initialState) {\n    currentHookNameInDev = 'useState';\n    mountHookTypesDev(); // DevTools를 위한 타입 추적\n\n    // 현재의 Dispatcher를 가져옴\n    var prevDispatcher = ReactCurrentDispatcher$1.current;\n    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;\n\n    try {\n        // 실제 상태 생성 로직인 mountState 호출\n        return mountState(initialState);\n    } finally {\n        ReactCurrentDispatcher$1.current = prevDispatcher;\n    }\n}\n```\n\n여기서 주목할 점은 `useState` 자체가 로직을 다 갖는게 아니라, 상황에 맞는 `Dispatcher(mountState)`를 호출한다는 점입니다. 그럼 Hook 객체를 생성하고 초기화하는 역할을 하는 `mountState` 로직의 중요한 부분만 살펴보겠습니다.\n\n```jsx\nfunction mountState(initialState) {\n  // 1. 현재 작업 중인 Hook 객체를 가져옴 (Fiber와 연결됨)\n  var hook = mountWorkInProgressHook();\n\n  // 2. 초기값 설정 (함수형 초기화 지원 - Lazy Initialization)\n  if (typeof initialState === \"function\") {\n    initialState = initialState();\n  }\n\n  // 3. Hook 객체에 상태 저장\n  hook.memoizedState = hook.baseState = initialState;\n\n  // 4. 업데이트 대기열(Queue) 생성\n  var queue = {\n    pending: null,\n    interleaved: null,\n    lanes: NoLanes,\n    dispatch: null,\n    lastRenderedReducer: basicStateReducer,\n    lastRenderedState: initialState,\n  };\n  hook.queue = queue;\n\n  // 5. dispatch 함수 생성 (우리가 아는 setState)\n  // dispatchSetState에 현재 Fiber와 Queue를 바인딩함\n  var dispatch = (queue.dispatch = dispatchSetState.bind(\n    null,\n    currentlyRenderingFiber$1,\n    queue,\n  ));\n\n  // 6. [상태값, setState함수] 반환\n  return [hook.memoizedState, dispatch];\n}\n```\n\nReact는 컴포넌트 내의 여러 Hook들을 **Linked List(연결 리스트)** 형태로 관리합니다.\n\n`mountWorkInProgressHook()`은 새로운 Hook 객체를 생성하고, 현재 Fiber 노드의 Hook 리스트 끝에 추가합니다. 이것이 바로 **\"Hook은 최상위에서, 순서대로 호출되어야 한다\"** 이라는 규칙입니다.\n\n우리가 사용하는 실제 state 값은 `hook.memoizedState`에 저장됩니다. 컴포넌트가 다시 렌더링될 때 React는 이 값을 가져옵니다. setState 함수(여기서는 dispatch)는 생성될 때 현재 컴포넌트의 Fiber(currentlyRenderingFiber$1)와 자신의 Queue 정보를 미리 바인딩해둡니다.\n\n덕분에 우리가 setState(3)처럼 값만 넘겨도, React의 내부적으로 **어떤 컴포넌트의 어떤 Hook을 업데이트해야 하는지** 정확히 알 수 있습니다.\n\n## 마치며\n\n단순해 보이는 `const [state,setState] = useState(initialState)` 한 줄 뒤에는 Fiber 아키텍처, 연결 리스트, 그리고 클로저의 개념을 활용하고 있습니다.\n이러한 내부 원리를 이해하면, 불필요한 렌더링을 막거나 복잡한 상태 관리 이슈를 디버깅할 때 훨씬 더 명확한 시야를 가질 수 있습니다. 앞으로 작성될 내용에서 지금은 가볍게 넘겼던 개념들을 깊게 다뤄보도록 하겠습니다.\n",
    "html": "<p>함수형 컴포넌트는 <strong>렌더링</strong>이 일어날 때마다 컴포넌트 함수가 다시 호출됩니다. 그래서 함수 내부의 일반변수는 호출이 끝나면 사라지고, 다음 렌더에서 처음부터 다시 만들어집니다. 그렇기에 <strong>렌더 사이에 유지되어야 하는 값</strong>을 일반 변수로 들고 있으면 값이 유지되지 않습니다.</p>\n<p>반대로 <code>useState</code>는 값이 컴포넌트 함수 안에 저장되는 게 아니라, React가 렌더 사이에 따로 보관하고 있다가, 해당 렌더 시점에 스냅샷처럼 꺼내서 컴포넌트에 제공합니다. 그래서 상태값은 <strong>변수처럼 바로 바뀌는 것</strong>이 아니라, <code>setState</code>를 호출하면 다음 렌더를 예약하고, 다음 렌더에서 바뀐 상태 스냅샷을 받게 됩니다.</p>\n<p>여기서 중요한 점은, props도 마찬가지로 <strong>그 렌더의 입력값</strong>입니다. 함수형 컴포넌트의 관점에서 props는 읽기 전용 입력이고, 컴포넌트는 props와 state로 UI를 계산해 내는 구조입니다. 상태를 바꾸고 싶다면 props를 건드리는 게 아니라 <code>setState</code>를 활용해 다음 렌더의 상태를 바꾸는 방식으로 접근해야 합니다.</p>\n<figure data-rehype-pretty-code-figure=\"\"><pre tabindex=\"0\" data-language=\"jsx\" data-theme=\"github-dark github-light\"><code data-language=\"jsx\" data-theme=\"github-dark github-light\" style=\"display: grid;\"><span data-line=\"\"><span style=\"--shiki-dark:#F97583;--shiki-light:#D73A49\">function</span><span style=\"--shiki-dark:#B392F0;--shiki-light:#6F42C1\"> Counter</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">() {</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#F97583;--shiki-light:#D73A49\">  let</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\"> local </span><span style=\"--shiki-dark:#F97583;--shiki-light:#D73A49\">=</span><span style=\"--shiki-dark:#79B8FF;--shiki-light:#005CC5\"> 0</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">;</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#F97583;--shiki-light:#D73A49\">  const</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\"> [</span><span style=\"--shiki-dark:#79B8FF;--shiki-light:#005CC5\">count</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">, </span><span style=\"--shiki-dark:#79B8FF;--shiki-light:#005CC5\">setCount</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">] </span><span style=\"--shiki-dark:#F97583;--shiki-light:#D73A49\">=</span><span style=\"--shiki-dark:#B392F0;--shiki-light:#6F42C1\"> useState</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">(</span><span style=\"--shiki-dark:#79B8FF;--shiki-light:#005CC5\">0</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">);</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"--shiki-dark:#F97583;--shiki-light:#D73A49\">  const</span><span style=\"--shiki-dark:#B392F0;--shiki-light:#6F42C1\"> onClick</span><span style=\"--shiki-dark:#F97583;--shiki-light:#D73A49\"> =</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\"> () </span><span style=\"--shiki-dark:#F97583;--shiki-light:#D73A49\">=></span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\"> {</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">    local </span><span style=\"--shiki-dark:#F97583;--shiki-light:#D73A49\">+=</span><span style=\"--shiki-dark:#79B8FF;--shiki-light:#005CC5\"> 1</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">;</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#B392F0;--shiki-light:#6F42C1\">    setCount</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">(count </span><span style=\"--shiki-dark:#F97583;--shiki-light:#D73A49\">+</span><span style=\"--shiki-dark:#79B8FF;--shiki-light:#005CC5\"> 1</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">);</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">    console.</span><span style=\"--shiki-dark:#B392F0;--shiki-light:#6F42C1\">log</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">(local, count);</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">  };</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"--shiki-dark:#F97583;--shiki-light:#D73A49\">  return</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\"> &#x3C;</span><span style=\"--shiki-dark:#85E89D;--shiki-light:#22863A\">button</span><span style=\"--shiki-dark:#B392F0;--shiki-light:#6F42C1\"> onClick</span><span style=\"--shiki-dark:#F97583;--shiki-light:#D73A49\">=</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">{onClick}>{count}&#x3C;/</span><span style=\"--shiki-dark:#85E89D;--shiki-light:#22863A\">button</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">>;</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">}</span></span></code></pre></figure>\n<p>여기서 <code>local</code> 변수는 렌더 사이에 유지되지 않기 때문에, 클릭할 때마다 <code>0</code>으로 초기화됩니다. 하지만 <code>count</code>는 <code>useState</code>를 통해 렌더 사이에 유지되므로, 클릭할 때마다 증가합니다. 하지만 <code>count</code>는 클릭하게되면 <code>setCount</code>가 현재 실행 중인 코드의 변수를 바꾸는게 아니라 다음 렌더를 트리거하기 때문에 클릭 즉시 바뀌지 않습니다.</p>\n<p>이 글에서 useState에 대해서 공식문서를 기준으로 값들이 어떻게 유지되고, 이어지는지에 대해서 이야기해보려합니다.</p>\n<h2 id=\"usestate-란-무엇인가\"><a class=\"anchor\" href=\"#usestate-란-무엇인가\">useState 란 무엇인가</a></h2>\n<p><code>useState</code>는 <strong>함수형 컴포넌트에 상태(state)를 추가</strong>하기 위한 Hook입니다. React는 상태를 컴포넌트 함수 내부 변수로 두는 게 아니라 <strong>렌더 사이에 별도로 보관</strong>해두고, 각 렌더마다 그 시점의 상태 <strong>스냅샷</strong>을 컴포넌트에 제공합니다. 그래서 상태를 바꾸는 행위는 <strong>현재 변수 값을 즉시 바꾸는 것</strong>이 아니라, <strong>다음 렌더에서 사용할 상태를 예약</strong>하는 방식으로 동작합니다.</p>\n<p><code>useState</code>는 길이가 2개인 배열을 반환합니다. <code>state</code>는 현재 렌더에서의 상태 값(첫 렌더에서는 <code>initialState</code>), <code>setState</code>는 상태를 업데이트하고 리렌더를 트리거하는 함수입니다.</p>\n<figure data-rehype-pretty-code-figure=\"\"><pre tabindex=\"0\" data-language=\"jsx\" data-theme=\"github-dark github-light\"><code data-language=\"jsx\" data-theme=\"github-dark github-light\" style=\"display: grid;\"><span data-line=\"\"><span style=\"--shiki-dark:#F97583;--shiki-light:#D73A49\">const</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\"> [</span><span style=\"--shiki-dark:#79B8FF;--shiki-light:#005CC5\">state</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">, </span><span style=\"--shiki-dark:#79B8FF;--shiki-light:#005CC5\">setState</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">] </span><span style=\"--shiki-dark:#F97583;--shiki-light:#D73A49\">=</span><span style=\"--shiki-dark:#B392F0;--shiki-light:#6F42C1\"> useState</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">(initialState);</span></span></code></pre></figure>\n<p><code>initialState</code>는 <code>useState</code>가 처음 렌더링 될 때 반환하는 <code>state</code>의 초기값입니다. 초기 렌더 이후에는 무시됩니다. 그리고 <code>initialState</code>로 함수를 넘기면 그 함수는 <strong>initializer function</strong>으로 취급되어, React가 <strong>초기화 시점에 호출한 반환값을 초기 상태로 저장</strong>합니다. 이 방식은 초기값 계산이 비싼 경우에 유용합니다.</p>\n<p>아래 코드가 어떤 차이점을 보이는지 살펴보겠습니다.</p>\n<figure data-rehype-pretty-code-figure=\"\"><pre tabindex=\"0\" data-language=\"jsx\" data-theme=\"github-dark github-light\"><code data-language=\"jsx\" data-theme=\"github-dark github-light\" style=\"display: grid;\"><span data-line=\"\"><span style=\"--shiki-dark:#B392F0;--shiki-light:#6F42C1\">useState</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">(</span><span style=\"--shiki-dark:#B392F0;--shiki-light:#6F42C1\">createInitialTodos</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">());</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#B392F0;--shiki-light:#6F42C1\">useState</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">(createInitialTodos);</span></span></code></pre></figure>\n<p>두 함수 <code>initialState</code>의 차이점은 언제 호출되어 초기값이 설정되는지에 있습니다.</p>\n<p>첫 번째 코드는 매 렌더마다 <code>createInitialTodos()</code>가 호출되어 초기값이 설정됩니다. 하지만 두 번째 코드는 초기화 시점에만 <code>createInitialTodos</code>를 호출하여 초기값을 만듭니다. (Lazy Initialization)</p>\n<details><summary>Lazy Initialization</summary><p>Lazy Initialization 은 <strong>useState의 초기값으로 값 대신 함수를 전달하여, 초기 로직이 첫 렌더링 시에만 실행되도록 하는 최적화 기법입니다.</strong></p><p><code>useState(heavyCalculation())</code>은 렌더링 될 때마다 heavyCalculation이 호출되어 낭비됩니다. 그래서 <code>useState(() => heavyCalculation())</code>로 최초 마운트 시에만 함수가 실행되고, 이후 리렌더링 때는 실행되지 않고 무시됩니다.</p></details>\n<p><code>setState</code>는 <strong>현재 실행 중인 코드의 state 변수를 즉시 바꾸지 않습니다.</strong> 따라서 <code>setState</code> 직후에 <code>state</code>를 읽으면 이전 렌더의 값이 그대로 나올 수 있습니다.</p>\n<p>또한 <code>nextState</code>로 함수를 넘기면 React는 그 함수를 Queue에 쌓아두고, 다음 렌더에서 쌓인 업데이터들을 순서대로 적용해 최종 상태를 계산합니다.</p>\n<p>그렇게되면 setState가 여러번 호출되어도 실제로는 한 번만 렌더링되는데, 이것을 성능 향상을 위해 여러 개의 상태 업데이트(setState)를 하나의 그룹으로 묶어서 한 번만 렌더링하는 React의 처리 방식인 <strong>배칭(batch)</strong> 이라고 합니다.</p>\n<blockquote>\n<p><a href=\"https://react.dev/blog/2022/03/29/react-v18\">React 18</a>부터는 기본적으로 배칭 범위가 더 넓어져서, React 이벤트 핸들러뿐 아니라 setTimeout, Promise 등에서도 자동 배칭이 적용될 수 있습니다</p>\n</blockquote>\n<p>새로 넣은 값이 현재 state와 동일한지 <code>Object.is</code>로 비교하고 판단되면, React는 리렌더를 스킵할 수 있습니다.</p>\n<p>여기서 중요한 포인트는 <strong>원시값(number,string,boolean)은 값 자체 비교</strong>라는 것 입니다, 하지만 <strong>객체/배열은 값이 아니라 참조(reference)가 같아야 동일한 값</strong>으로 취급됩니다. 객체를 직접 수정(mutation)하면 참조가 유지되기 때문에 바뀐 것처럼 보이는데 리렌더가 안되거나/반대로 상태 불변성이 깨져 디버깅이 어려워지는 문제가 발생합니다.</p>\n<h2 id=\"내부-동작\"><a class=\"anchor\" href=\"#내부-동작\">내부 동작</a></h2>\n<p>React를 사용하면 가장 쉽게 접하는 Hook 중 하나인 <code>useState</code>의 내부 코드를 살펴보면 수많은 자바스크립트 로직이 서로 얽혀져 있는 모습을 볼 수 있습니다. 내부 코드를 통해 <code>useState</code>가 상태를 어떻게 관리하고 있는지 살펴봅시다.</p>\n<p><code>useState</code>를 이해하기 위해서는 <strong>클로저(Closure)를</strong> 이해해야 합니다.</p>\n<p>함수형 컴포넌트는 렌더링될 때마다 다시 호출됩니다. 그럼에도 부구하고 이전 상태값을 기억하는 이유는 무엇일까요? 아래 자바스크립트로 <code>useState</code>를 구현한 코드를 살펴보겠습니다.</p>\n<figure data-rehype-pretty-code-figure=\"\"><pre tabindex=\"0\" data-language=\"jsx\" data-theme=\"github-dark github-light\"><code data-language=\"jsx\" data-theme=\"github-dark github-light\" style=\"display: grid;\"><span data-line=\"\"><span style=\"--shiki-dark:#F97583;--shiki-light:#D73A49\">function</span><span style=\"--shiki-dark:#B392F0;--shiki-light:#6F42C1\"> useState</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">(</span><span style=\"--shiki-dark:#FFAB70;--shiki-light:#E36209\">initialValue</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">) {</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#F97583;--shiki-light:#D73A49\">  var</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\"> _val </span><span style=\"--shiki-dark:#F97583;--shiki-light:#D73A49\">=</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\"> initialValue; </span><span style=\"--shiki-dark:#6A737D;--shiki-light:#6A737D\">// 1. _val은 지역 변수이지만 클로저에 의해 캡처됨</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"--shiki-dark:#F97583;--shiki-light:#D73A49\">  function</span><span style=\"--shiki-dark:#B392F0;--shiki-light:#6F42C1\"> state</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">() {</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#6A737D;--shiki-light:#6A737D\">    // state는 내부 함수이자 클로저</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#F97583;--shiki-light:#D73A49\">    return</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\"> _val; </span><span style=\"--shiki-dark:#6A737D;--shiki-light:#6A737D\">// 부모 함수의 _val을 참조</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">  }</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"--shiki-dark:#F97583;--shiki-light:#D73A49\">  function</span><span style=\"--shiki-dark:#B392F0;--shiki-light:#6F42C1\"> setState</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">(</span><span style=\"--shiki-dark:#FFAB70;--shiki-light:#E36209\">newVal</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">) {</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#6A737D;--shiki-light:#6A737D\">    // _val 값을 직접 수정 (이 변수는 외부에서 접근 불가)</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">    _val </span><span style=\"--shiki-dark:#F97583;--shiki-light:#D73A49\">=</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\"> newVal;</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">  }</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"--shiki-dark:#F97583;--shiki-light:#D73A49\">  return</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\"> [state, setState]; </span><span style=\"--shiki-dark:#6A737D;--shiki-light:#6A737D\">// 외부로 함수 노출</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">}</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"--shiki-dark:#F97583;--shiki-light:#D73A49\">var</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\"> [foo, setFoo] </span><span style=\"--shiki-dark:#F97583;--shiki-light:#D73A49\">=</span><span style=\"--shiki-dark:#B392F0;--shiki-light:#6F42C1\"> useState</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">(</span><span style=\"--shiki-dark:#79B8FF;--shiki-light:#005CC5\">0</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">);</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">console.</span><span style=\"--shiki-dark:#B392F0;--shiki-light:#6F42C1\">log</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">(</span><span style=\"--shiki-dark:#B392F0;--shiki-light:#6F42C1\">foo</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">()); </span><span style=\"--shiki-dark:#6A737D;--shiki-light:#6A737D\">// 0</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#B392F0;--shiki-light:#6F42C1\">setFoo</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">(</span><span style=\"--shiki-dark:#79B8FF;--shiki-light:#005CC5\">1</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">);</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">console.</span><span style=\"--shiki-dark:#B392F0;--shiki-light:#6F42C1\">log</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">(</span><span style=\"--shiki-dark:#B392F0;--shiki-light:#6F42C1\">foo</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">()); </span><span style=\"--shiki-dark:#6A737D;--shiki-light:#6A737D\">// 1</span></span></code></pre></figure>\n<p><code>useState</code>는 함수가 호출되고 종료되어도, 반환된 state, setState 함수는 <strong>자신이 생성될 당시의 스코프(Lexical Environment)를 기억</strong>합니다. 따라서 <code>_val</code>이라는 변수는 메모리 어딘가에 살아남아 값을 유지하게 됩니다.</p>\n<h3 id=\"reacthooksjs\"><a class=\"anchor\" href=\"#reacthooksjs\">ReactHooks.js</a></h3>\n<p>실제 React에서는 수많은 컴포넌트의 수많은 Hook들을 순서대로 관리해야하기에 내부 구조가 많이 복잡합니다. 그래서 <a href=\"https://github.com/facebook/react/blob/main/packages/react/src/ReactHooks.js\">모든 내부 구조</a>를 살펴보는 것 보다는 필요한 부분만 살펴보도록 하겠습니다.</p>\n<p>React는 컴포넌트가 <strong>처음 렌더링될 때(Mount)와 업데이트 될 때(Update) 서로 다른 Dispatcher를 사용</strong>합니다.</p>\n<p>아래 코드는 컴포넌트가 처음 마운트될 때 실행되는 <code>useState</code>의 진입점입니다</p>\n<figure data-rehype-pretty-code-figure=\"\"><pre tabindex=\"0\" data-language=\"jsx\" data-theme=\"github-dark github-light\"><code data-language=\"jsx\" data-theme=\"github-dark github-light\" style=\"display: grid;\"><span data-line=\"\"><span style=\"--shiki-dark:#B392F0;--shiki-light:#6F42C1\">useState</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">: </span><span style=\"--shiki-dark:#F97583;--shiki-light:#D73A49\">function</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\"> (</span><span style=\"--shiki-dark:#FFAB70;--shiki-light:#E36209\">initialState</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">) {</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">    currentHookNameInDev </span><span style=\"--shiki-dark:#F97583;--shiki-light:#D73A49\">=</span><span style=\"--shiki-dark:#9ECBFF;--shiki-light:#032F62\"> 'useState'</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">;</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#B392F0;--shiki-light:#6F42C1\">    mountHookTypesDev</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">(); </span><span style=\"--shiki-dark:#6A737D;--shiki-light:#6A737D\">// DevTools를 위한 타입 추적</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"--shiki-dark:#6A737D;--shiki-light:#6A737D\">    // 현재의 Dispatcher를 가져옴</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#F97583;--shiki-light:#D73A49\">    var</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\"> prevDispatcher </span><span style=\"--shiki-dark:#F97583;--shiki-light:#D73A49\">=</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\"> ReactCurrentDispatcher$1.current;</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">    ReactCurrentDispatcher$1.current </span><span style=\"--shiki-dark:#F97583;--shiki-light:#D73A49\">=</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\"> InvalidNestedHooksDispatcherOnMountInDEV;</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"--shiki-dark:#F97583;--shiki-light:#D73A49\">    try</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\"> {</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#6A737D;--shiki-light:#6A737D\">        // 실제 상태 생성 로직인 mountState 호출</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#F97583;--shiki-light:#D73A49\">        return</span><span style=\"--shiki-dark:#B392F0;--shiki-light:#6F42C1\"> mountState</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">(initialState);</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">    } </span><span style=\"--shiki-dark:#F97583;--shiki-light:#D73A49\">finally</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\"> {</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">        ReactCurrentDispatcher$1.current </span><span style=\"--shiki-dark:#F97583;--shiki-light:#D73A49\">=</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\"> prevDispatcher;</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">    }</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">}</span></span></code></pre></figure>\n<p>여기서 주목할 점은 <code>useState</code> 자체가 로직을 다 갖는게 아니라, 상황에 맞는 <code>Dispatcher(mountState)</code>를 호출한다는 점입니다. 그럼 Hook 객체를 생성하고 초기화하는 역할을 하는 <code>mountState</code> 로직의 중요한 부분만 살펴보겠습니다.</p>\n<figure data-rehype-pretty-code-figure=\"\"><pre tabindex=\"0\" data-language=\"jsx\" data-theme=\"github-dark github-light\"><code data-language=\"jsx\" data-theme=\"github-dark github-light\" style=\"display: grid;\"><span data-line=\"\"><span style=\"--shiki-dark:#F97583;--shiki-light:#D73A49\">function</span><span style=\"--shiki-dark:#B392F0;--shiki-light:#6F42C1\"> mountState</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">(</span><span style=\"--shiki-dark:#FFAB70;--shiki-light:#E36209\">initialState</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">) {</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#6A737D;--shiki-light:#6A737D\">  // 1. 현재 작업 중인 Hook 객체를 가져옴 (Fiber와 연결됨)</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#F97583;--shiki-light:#D73A49\">  var</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\"> hook </span><span style=\"--shiki-dark:#F97583;--shiki-light:#D73A49\">=</span><span style=\"--shiki-dark:#B392F0;--shiki-light:#6F42C1\"> mountWorkInProgressHook</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">();</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"--shiki-dark:#6A737D;--shiki-light:#6A737D\">  // 2. 초기값 설정 (함수형 초기화 지원 - Lazy Initialization)</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#F97583;--shiki-light:#D73A49\">  if</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\"> (</span><span style=\"--shiki-dark:#F97583;--shiki-light:#D73A49\">typeof</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\"> initialState </span><span style=\"--shiki-dark:#F97583;--shiki-light:#D73A49\">===</span><span style=\"--shiki-dark:#9ECBFF;--shiki-light:#032F62\"> \"function\"</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">) {</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">    initialState </span><span style=\"--shiki-dark:#F97583;--shiki-light:#D73A49\">=</span><span style=\"--shiki-dark:#B392F0;--shiki-light:#6F42C1\"> initialState</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">();</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">  }</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"--shiki-dark:#6A737D;--shiki-light:#6A737D\">  // 3. Hook 객체에 상태 저장</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">  hook.memoizedState </span><span style=\"--shiki-dark:#F97583;--shiki-light:#D73A49\">=</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\"> hook.baseState </span><span style=\"--shiki-dark:#F97583;--shiki-light:#D73A49\">=</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\"> initialState;</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"--shiki-dark:#6A737D;--shiki-light:#6A737D\">  // 4. 업데이트 대기열(Queue) 생성</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#F97583;--shiki-light:#D73A49\">  var</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\"> queue </span><span style=\"--shiki-dark:#F97583;--shiki-light:#D73A49\">=</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\"> {</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">    pending: </span><span style=\"--shiki-dark:#79B8FF;--shiki-light:#005CC5\">null</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">,</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">    interleaved: </span><span style=\"--shiki-dark:#79B8FF;--shiki-light:#005CC5\">null</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">,</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">    lanes: NoLanes,</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">    dispatch: </span><span style=\"--shiki-dark:#79B8FF;--shiki-light:#005CC5\">null</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">,</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">    lastRenderedReducer: basicStateReducer,</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">    lastRenderedState: initialState,</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">  };</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">  hook.queue </span><span style=\"--shiki-dark:#F97583;--shiki-light:#D73A49\">=</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\"> queue;</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"--shiki-dark:#6A737D;--shiki-light:#6A737D\">  // 5. dispatch 함수 생성 (우리가 아는 setState)</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#6A737D;--shiki-light:#6A737D\">  // dispatchSetState에 현재 Fiber와 Queue를 바인딩함</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#F97583;--shiki-light:#D73A49\">  var</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\"> dispatch </span><span style=\"--shiki-dark:#F97583;--shiki-light:#D73A49\">=</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\"> (queue.dispatch </span><span style=\"--shiki-dark:#F97583;--shiki-light:#D73A49\">=</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\"> dispatchSetState.</span><span style=\"--shiki-dark:#B392F0;--shiki-light:#6F42C1\">bind</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">(</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#79B8FF;--shiki-light:#005CC5\">    null</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">,</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">    currentlyRenderingFiber$1,</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">    queue,</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">  ));</span></span>\n<span data-line=\"\"> </span>\n<span data-line=\"\"><span style=\"--shiki-dark:#6A737D;--shiki-light:#6A737D\">  // 6. [상태값, setState함수] 반환</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#F97583;--shiki-light:#D73A49\">  return</span><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\"> [hook.memoizedState, dispatch];</span></span>\n<span data-line=\"\"><span style=\"--shiki-dark:#E1E4E8;--shiki-light:#24292E\">}</span></span></code></pre></figure>\n<p>React는 컴포넌트 내의 여러 Hook들을 <strong>Linked List(연결 리스트)</strong> 형태로 관리합니다.</p>\n<p><code>mountWorkInProgressHook()</code>은 새로운 Hook 객체를 생성하고, 현재 Fiber 노드의 Hook 리스트 끝에 추가합니다. 이것이 바로 <strong>\"Hook은 최상위에서, 순서대로 호출되어야 한다\"</strong> 이라는 규칙입니다.</p>\n<p>우리가 사용하는 실제 state 값은 <code>hook.memoizedState</code>에 저장됩니다. 컴포넌트가 다시 렌더링될 때 React는 이 값을 가져옵니다. setState 함수(여기서는 dispatch)는 생성될 때 현재 컴포넌트의 Fiber(currentlyRenderingFiber$1)와 자신의 Queue 정보를 미리 바인딩해둡니다.</p>\n<p>덕분에 우리가 setState(3)처럼 값만 넘겨도, React의 내부적으로 <strong>어떤 컴포넌트의 어떤 Hook을 업데이트해야 하는지</strong> 정확히 알 수 있습니다.</p>\n<h2 id=\"마치며\"><a class=\"anchor\" href=\"#마치며\">마치며</a></h2>\n<p>단순해 보이는 <code>const [state,setState] = useState(initialState)</code> 한 줄 뒤에는 Fiber 아키텍처, 연결 리스트, 그리고 클로저의 개념을 활용하고 있습니다.\n이러한 내부 원리를 이해하면, 불필요한 렌더링을 막거나 복잡한 상태 관리 이슈를 디버깅할 때 훨씬 더 명확한 시야를 가질 수 있습니다. 앞으로 작성될 내용에서 지금은 가볍게 넘겼던 개념들을 깊게 다뤄보도록 하겠습니다.</p>"
  },
  "_id": "230820/index.md",
  "_raw": {
    "sourceFilePath": "230820/index.md",
    "sourceFileName": "index.md",
    "sourceFileDir": "230820",
    "contentType": "markdown",
    "flattenedPath": "230820"
  },
  "type": "Post",
  "slug": "/230820",
  "categoryArray": [
    "프론트엔드",
    "React"
  ],
  "readingTime": "14 min read",
  "excerpt": "함수형 컴포넌트는 렌더링이 일어날 때마다 컴포넌트 함수가 다시 호출됩니다. 그래서 함수 내부의 일반변수는 호출이 끝나면 사라지고, 다음 렌더에서 처음부터 다시 만들어집니다. 그렇기에 렌더 사이에 유지되어야 하는 값을 일반 변수로 들고 있으면 값이 유지되지 않습니다. 반대로 useState는 값이 컴포넌트 함수 안에 저장되는 게 아니라, React가 렌더 사..."
}